{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @typedef {string} KeyCombo - A `+` delimited key combination (e.g. `Ctrl+Home`)\n */\n\n/**\n * @typedef {Object} VKMap - A map between virtual keys and key combinations\n * @property {KeyCombo[]} [TOP_LEFT] - The top left key combination\n * @property {KeyCombo[]} [TOP] - The top key combination\n * @property {KeyCombo[]} [TOP_RIGHT] - The top right key combination\n * @property {KeyCombo[]} [UP] - The up key combination\n * @property {KeyCombo[]} [DOWN] - The down key combination\n * @property {KeyCombo[]} [HOME] - The home key combination\n * @property {KeyCombo[]} [END] - The end key combination\n * @property {KeyCombo[]} [LEFT] - The left key combination\n * @property {KeyCombo[]} [RIGHT] - The right key combination\n * @property {KeyCombo[]} [BOTTOM_LEFT] - The bottom left key combination\n * @property {KeyCombo[]} [BOTTOM] - The bottom key combination\n * @property {KeyCombo[]} [BOTTOM_RIGHT] - The bottom right key combination\n *\n */\n\n/**\n * @typedef {Object} KeyLookup - A map between key combinations and virtual keys\n */\n\nconst state = new Map();\nconst isRtl =\n  window.getComputedStyle(document.documentElement).direction === \"rtl\";\n\n/**\n * @type {VKMap}\n */\nconst DEFAULT_VK_MAP = {\n  TOP_LEFT: [],\n  TOP: [\"Ctrl+Home\", \"Meta+ArrowUp\"],\n  TOP_RIGHT: [],\n  UP: [\"ArrowUp\"],\n  DOWN: [\"ArrowDown\"],\n  HOME: [\"Home\", \"Meta+ArrowLeft\"],\n  END: [\"End\", \"Meta+ArrowRight\"],\n  LEFT: [\"ArrowLeft\"],\n  RIGHT: [\"ArrowRight\"],\n  BOTTOM_LEFT: [],\n  BOTTOM: [\"Ctrl+End\", \"Meta+ArrowDown\"],\n  BOTTOM_RIGHT: [],\n};\n\n/**\n * Returns a string for the pressed key combination, combining all modifiers\n * with '+' in order: Ctrl (^), Alt (⌥), Shift (⇧), Meta (⌘)\n *\n * @param {KeyboardEvent} e The keyboard event\n * @returns {KeyCombo} The key combination\n */\nconst keyCombo = (e) => {\n  const modifiers = [\n    e.ctrlKey ? \"Ctrl\" : null,\n    e.altKey ? \"Alt\" : null,\n    e.shiftKey ? \"Shift\" : null,\n    e.metaKey ? \"Meta\" : null,\n  ].filter(Boolean);\n  const key = e.key.length === 1 ? e.key.toUpperCase() : e.key;\n\n  return modifiers.length > 0 ? modifiers.join(\"+\") + `+${key}` : key;\n};\n\n/**\n * Swaps a key combo with a key combo in a list of key combos.\n * Used to translate from Ltr to Rtl for HOME and END virtual keys\n * @param {KeyCombo[]} keys - The key combos to swap with\n * @param {KeyCombo} key - The key to swap\n * @returns {KeyCombo} The swapped key\n */\nconst swapKeys = (keys, key) => {\n  if ((key.includes(\"ArrowLeft\") || key.length == 1) && !key.includes(\"Home\")) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowRight\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  } else if (\n    (key.includes(\"ArrowRight\") || key.length == 1) &&\n    !key.includes(\"End\")\n  ) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowLeft\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  }\n  return key;\n};\n\n/**\n * Returns a virtual key lookup for each key combination, handles Rtl\n * @param {VKMap} [VKMap] - The virtual key map\n * @returns {KeyLookup} The virtual key lookup map for each key combination\n */\nconst keyLookup = (VKMap = {}) => {\n  const keyMap = { ...DEFAULT_VK_MAP, ...VKMap };\n\n  if (isRtl) {\n    // Swap functionality of LEFT and RIGHT for Rtl\n    [keyMap.LEFT, keyMap.RIGHT] = [keyMap.RIGHT, keyMap.LEFT];\n    [keyMap.TOP_LEFT, keyMap.TOP_RIGHT] = [keyMap.TOP_RIGHT, keyMap.TOP_LEFT];\n    [keyMap.BOTTOM_LEFT, keyMap.BOTTOM_RIGHT] = [\n      keyMap.BOTTOM_RIGHT,\n      keyMap.BOTTOM_LEFT,\n    ];\n\n    // Swap HOME and END\n    const homeKeys = keyMap.HOME;\n    const endKeys = keyMap.END;\n    keyMap.HOME = homeKeys.map((key) => swapKeys(endKeys, key));\n    keyMap.END = endKeys.map((key) => swapKeys(homeKeys, key));\n  }\n\n  // Convert single characters to uppercase\n  for (const action in keyMap) {\n    keyMap[action] = keyMap[action].map((keyCombo) => {\n      const keys = keyCombo.split(\"+\");\n      const updatedKeys = keys.map((key) => {\n        return key.length === 1 ? key.toUpperCase() : key;\n      });\n      return updatedKeys.join(\"+\");\n    });\n  }\n\n  // Convert the keymap into a lookup for faster access\n  const keyLookup = {};\n  for (const action in keyMap) {\n    keyMap[action].forEach((keyCombo) => {\n      keyLookup[keyCombo] = action;\n    });\n  }\n  return keyLookup;\n};\n\n// When pointerdown, activate the target\nconst onPointerDown = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  const targetsArray = [...rx.targets];\n  for (const [i, t] of targetsArray.entries()) {\n    if (t.contains(e.target)) {\n      e.preventDefault();\n      rx.index = i;\n      rx.focused = true;\n      activate(rover, t);\n      state.set(\"last_rover\", rover);\n      break;\n    }\n  }\n};\n\n// When focusin, activate the target if not active\nconst onFocusin = (e) => {\n  const { currentTarget: rover, target } = e;\n  if (state.has(rover)) {\n    const rx = state.get(rover);\n    const targetIndex = [...rx.targets].indexOf(target);\n    if (targetIndex !== -1 && rx.index !== targetIndex) {\n      rx.index = targetIndex;\n      rx.focused = true;\n      activate(rover, target);\n      state.set(\"last_rover\", rover);\n    }\n  }\n};\n\nconst onFocusout = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  if (rx) rx.focused = false;\n};\n\nconst onKeydown = (e) => {\n  const { currentTarget: rover } = e;\n  const key = keyCombo(e);\n  const { keyBinds } = state.get(rover);\n  switch (keyBinds[key]) {\n    case \"RIGHT\":\n      e.preventDefault();\n      focusNextItem(rover);\n      break;\n    case \"LEFT\":\n      e.preventDefault();\n      focusPreviousItem(rover);\n      break;\n    case \"DOWN\":\n      e.preventDefault();\n      focusDownItem(rover);\n      break;\n    case \"UP\":\n      e.preventDefault();\n      focusUpItem(rover);\n      break;\n    case \"HOME\":\n      e.preventDefault();\n      focusHomeItem(rover);\n      break;\n    case \"END\":\n      e.preventDefault();\n      focusEndItem(rover);\n      break;\n    case \"BOTTOM\":\n      e.preventDefault();\n      focusBottomItem(rover);\n      break;\n    case \"TOP\":\n      e.preventDefault();\n      focusTopItem(rover);\n      break;\n    case \"TOP_LEFT\":\n      e.preventDefault();\n      focusTopLeadingItem(rover);\n      break;\n    case \"TOP_RIGHT\":\n      e.preventDefault();\n      focusTopTrailingItem(rover);\n      break;\n    case \"BOTTOM_LEFT\":\n      e.preventDefault();\n      focusBottomLeadingItem(rover);\n      break;\n    case \"BOTTOM_RIGHT\":\n      e.preventDefault();\n      focusBottomTrailingItem(rover);\n      break;\n  }\n};\n\nconst onDOMChange = (rover, targetSelector) => {\n  const updatedTargets = rover.querySelectorAll(targetSelector);\n\n  const columns = numColumns(rover, updatedTargets);\n  const rows = numRows(rover, updatedTargets);\n\n  const rx = state.get(rover);\n  const currentColumns = rx.columns;\n  const currentIndex = rx.index;\n  const currentRowIndex = Math.floor(currentIndex / currentColumns);\n  const currentColumnIndex = currentIndex % currentColumns;\n\n  const targetIndex =\n    Math.min(currentRowIndex, rows - 1) * columns +\n    Math.min(currentColumnIndex, columns - 1);\n  const targetPoint = updatedTargets[targetIndex];\n\n  let startingPoint, index;\n  if (!(targetPoint.disabled || targetPoint.inert)) {\n    startingPoint = targetPoint;\n    index = targetIndex;\n  } else {\n    for (const target of updatedTargets) {\n      if (!target.disabled && !target.inert) {\n        startingPoint = target;\n        break;\n      }\n    }\n    index = [...updatedTargets].indexOf(startingPoint);\n  }\n\n  updatedTargets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n  rx.focused && activate(rover, startingPoint);\n\n  state.set(rover, {\n    ...rx,\n    targets: updatedTargets,\n    columns,\n    rows,\n    active: startingPoint,\n    index,\n  });\n};\n\nconst onResize = (rover) => {\n  const rx = state.get(rover);\n  const columns = numColumns(rover, [...rx.targets]);\n  const rows = numRows(rover, [...rx.targets]);\n\n  state.set(rover, {\n    ...rx,\n    columns,\n    rows,\n  });\n};\n\nconst createRoverObserver = (rover, { observers = [] } = {}) => {\n  const parent = rover.parentNode;\n  const mo = new MutationObserver((mutationList, observer) => {\n    mutationList\n      .filter((x) => x.removedNodes.length > 0)\n      .forEach((mutation) => {\n        [...mutation.removedNodes]\n          .filter((x) => x.nodeType === 1)\n          .forEach((removedEl) => {\n            state.forEach((val, key) => {\n              if (key === \"last_rover\") return;\n              if (removedEl.contains(key)) {\n                key.removeEventListener(\"pointerdown\", onPointerDown);\n                key.removeEventListener(\"focusin\", onFocusin);\n                key.removeEventListener(\"focusout\", onFocusout);\n                key.removeEventListener(\"keydown\", onKeydown);\n\n                state.delete(key);\n                val.targets.forEach((a) => (a.tabIndex = \"\"));\n\n                if (\n                  state.size === 0 ||\n                  (state.size === 1 && state.has(\"last_rover\"))\n                ) {\n                  state.clear();\n                  mo.disconnect();\n                  observers.forEach((o) => o.disconnect());\n                }\n              }\n            });\n          });\n      });\n  });\n\n  mo.observe(parent, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\nconst createMutationObserver = (rover, targetSelector) => {\n  const mo = new MutationObserver((mutationList, observer) => {\n    mutationList.forEach((mutation) => {\n      if (mutation.type === \"childList\" && rover.contains(mutation.target)) {\n        onDOMChange(rover, targetSelector);\n      }\n    });\n  });\n\n  mo.observe(rover, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\nconst createResizeObserver = (rover, targetSelector) => {\n  const ro = new ResizeObserver((entries) => {\n    for (const entry of entries) {\n      onResize(rover);\n    }\n  });\n\n  ro.observe(rover);\n  rover.querySelectorAll(targetSelector).forEach((t) => {\n    ro.observe(t);\n  });\n\n  return ro;\n};\n\n/**\n * Calculates the number of columns in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of columns\n */\nconst numColumns = (container, targets) => {\n  // If the container uses CSS grid, get the number of columns from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-columns\");\n  if (cssGrid) {\n    return gridComputedStyle\n      .getPropertyValue(\"grid-template-columns\")\n      .split(\" \").length;\n  }\n\n  // Otherwise, calculate the number of columns with brute force using the\n  // offset widths and gaps between cells\n  const containerWidth = container.offsetWidth;\n  const targetsArray = [...targets];\n  let acc = 0;\n  let n = 0;\n  for (let i = 0, m = targetsArray.length; i < m; i++) {\n    const cell = targetsArray[i];\n\n    acc += Math.floor(cell.offsetWidth);\n\n    const nextCell = targets[i + 1];\n\n    if (nextCell) {\n      const gap = nextCell.offsetLeft - (cell.offsetLeft + cell.offsetWidth);\n      if (gap > 0) acc += Math.floor(gap);\n    }\n\n    if (acc > containerWidth) {\n      break;\n    }\n    n++;\n  }\n  return n;\n};\n\n/**\n * Calculates the number of rows in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of rows\n */\nconst numRows = (container, targets) => {\n  // If the container uses CSS grid, get the number of rows from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-rows\");\n  if (cssGrid) {\n    return gridComputedStyle.getPropertyValue(\"grid-template-rows\").split(\" \")\n      .length;\n  }\n\n  // Otherwise, calculate the number of rows as the number of targets divided\n  // by the number of columns\n  return Math.ceil(targets.length / numColumns(container, targets));\n};\n\n/**\n * @param {Object} props - The props object\n * @param {HTMLElement} props.element - The target container element\n * @param {string} [props.target] - The selector for focus targets (e.g. cells)\n * @param {boolean} [props.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [props.VKMap={}] - The virtual key map for key combos\n */\nexport const rovingGrid = ({\n  element: rover,\n  target: targetSelector = \":scope *\",\n  wrap = true,\n  VKMap = {},\n}) => {\n  const targets = rover.querySelectorAll(targetSelector);\n  let startingPoint;\n  for (const target of targets) {\n    if (!target.disabled && !target.inert) {\n      startingPoint = target;\n      break;\n    }\n  }\n  const index = [...targets].indexOf(startingPoint);\n  const columns = numColumns(rover, targets);\n  const rows = numRows(rover, targets);\n  const keyBinds = keyLookup(VKMap);\n\n  rover.tabIndex = -1;\n  targets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    wrap,\n    active: startingPoint,\n    index,\n    rows,\n    columns,\n    focused: false,\n    keyBinds,\n  });\n\n  rover.addEventListener(\"pointerdown\", onPointerDown);\n  rover.addEventListener(\"focusin\", onFocusin);\n  rover.addEventListener(\"focusout\", onFocusout);\n  rover.addEventListener(\"keydown\", onKeydown);\n\n  const mo = createMutationObserver(rover, targetSelector);\n  const ro = createResizeObserver(rover, targetSelector);\n  createRoverObserver(rover, { observers: [mo, ro] });\n};\n\n/**\n * @typedef {Object} RoverOptions - Options for roving grid\n * @param {boolean} [options.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [options.VKMap={}] - The virtual key map for key combos\n */\n\n/**\n * Updates the rover for on-the-fly customization of `wrap` and `VKMap`\n * @param {HTMLElement} rover - The element with roving focus\n * @param {RoverOptions} options - The roving grid options\n */\nexport const updateRover = (rover, options) => {\n  const currentState = state.get(rover);\n\n  if (!currentState) {\n    throw new Error(\"Rover not found\");\n  }\n\n  const updatedState = {\n    ...currentState,\n    ...options,\n  };\n\n  if (options.VKMap) {\n    updatedState.keyBinds = keyLookup(options.VKMap);\n  }\n\n  state.set(rover, updatedState);\n};\n\nconst focusNextItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const maxIndex = rx.wrap\n    ? rx.targets.length - 1\n    : (rowIndex + 1) * rx.columns - 1;\n  let nextIndex = rx.index;\n\n  while (nextIndex < maxIndex) {\n    nextIndex++;\n    const next = rx.targets[nextIndex];\n    if (next && !(next.inert || next.disabled)) {\n      rx.index = nextIndex;\n      activate(rover, next);\n      break;\n    }\n  }\n};\n\nconst focusPreviousItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const minIndex = rx.wrap ? 0 : rowIndex * rx.columns;\n  let previousIndex = rx.index;\n\n  while (previousIndex > minIndex) {\n    previousIndex--;\n    const prev = rx.targets[previousIndex];\n    if (prev && !(prev.inert || prev.disabled)) {\n      rx.index = previousIndex;\n      activate(rover, prev);\n      break;\n    }\n  }\n};\n\nconst focusDownItem = (rover) => {\n  const rx = state.get(rover);\n  const maxIndex = rx.rows * rx.columns + (rx.index % rx.columns);\n  let downIndex = rx.index;\n\n  while (downIndex < maxIndex) {\n    downIndex += rx.columns;\n    const down = rx.targets[downIndex];\n    if (down && !(down.inert || down.disabled)) {\n      rx.index = downIndex;\n      activate(rover, down);\n      break;\n    }\n  }\n};\n\nconst focusUpItem = (rover) => {\n  const rx = state.get(rover);\n  const minIndex = rx.index % rx.columns;\n  let upIndex = rx.index;\n\n  while (upIndex > minIndex) {\n    upIndex -= rx.columns;\n    const up = rx.targets[upIndex];\n    if (up && !(up.inert || up.disabled)) {\n      rx.index = upIndex;\n      activate(rover, up);\n      break;\n    }\n  }\n};\n\nconst focusHomeItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = 0;\n\n  // Find smallest column index that has a target\n  while (targetColumnIndex < rx.columns) {\n    const homeTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (homeTarget && !(homeTarget.inert || homeTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex++;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const home = rx.targets[rx.index];\n\n  home && activate(rover, home);\n};\n\nconst focusEndItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = rx.columns - 1;\n\n  // Find largest column index that has a target\n  while (targetColumnIndex >= 0) {\n    const endTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (endTarget && !(endTarget.inert || endTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex--;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const end = rx.targets[rx.index];\n\n  end && activate(rover, end);\n};\n\nconst focusTopItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = 0;\n\n  // Find smallest row index that has a target\n  while (targetRowIndex < rowIndex) {\n    const topTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (topTarget && !(topTarget.inert || topTarget.disabled)) {\n      break;\n    }\n    targetRowIndex++;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const top = rx.targets[rx.index];\n\n  top && activate(rover, top);\n};\n\nconst focusBottomItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = rx.rows - 1;\n\n  // Find largest row index that has a target\n  while (targetRowIndex > rowIndex) {\n    const bottomTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (bottomTarget && !(bottomTarget.inert || bottomTarget.disabled)) {\n      break;\n    }\n    targetRowIndex--;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const bottom = rx.targets[rx.index];\n\n  bottom && activate(rover, bottom);\n};\n\nconst focusTopLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const topLeading = rx.targets[0];\n\n  if (topLeading && !(topLeading.inert || topLeading.disabled)) {\n    rx.index = 0;\n    activate(rover, topLeading);\n  }\n};\n\nconst focusTopTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const topTrailing = rx.targets[rx.columns - 1];\n\n  if (topTrailing && !(topTrailing.inert || topTrailing.disabled)) {\n    rx.index = rx.columns - 1;\n    activate(rover, topTrailing);\n  }\n};\n\nconst focusBottomLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomLeading = rx.targets[rx.columns * (rx.rows - 1)];\n\n  if (bottomLeading && !(bottomLeading.inert || bottomLeading.disabled)) {\n    rx.index = rx.columns * (rx.rows - 1);\n    activate(rover, bottomLeading);\n  }\n};\n\nconst focusBottomTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomTrailing = rx.targets[rx.columns * rx.rows - 1];\n\n  if (bottomTrailing && !(bottomTrailing.inert || bottomTrailing.disabled)) {\n    rx.index = rx.columns * rx.rows - 1;\n    activate(rover, bottomTrailing);\n  }\n};\n\nconst activate = (rover, item) => {\n  const rx = state.get(rover);\n\n  rx.active.tabIndex = -1;\n  rx.active = item;\n  rx.active.tabIndex = 0;\n  rx.active.focus();\n  rx.focused = true;\n};\n"],"names":["state","Map","isRtl","window","getComputedStyle","document","documentElement","direction","DEFAULT_VK_MAP","TOP_LEFT","TOP","TOP_RIGHT","UP","DOWN","HOME","END","LEFT","RIGHT","BOTTOM_LEFT","BOTTOM","BOTTOM_RIGHT","swapKeys","keys","key","includes","length","i","findIndex","k","keyLookup","VKMap","keyMap","_extends","_ref","_ref2","_ref3","homeKeys","endKeys","map","action","keyCombo","split","toUpperCase","join","_loop","_action","forEach","onPointerDown","e","_step","rover","currentTarget","rx","get","_iterator","_createForOfIteratorHelperLoose","concat","targets","entries","done","_step$value","value","t","contains","target","preventDefault","index","focused","activate","set","onFocusin","has","targetIndex","indexOf","onFocusout","onKeydown","modifiers","ctrlKey","altKey","shiftKey","metaKey","filter","Boolean","keyBinds","focusNextItem","focusPreviousItem","focusDownItem","focusUpItem","focusHomeItem","focusEndItem","focusBottomItem","focusTopItem","focusTopLeadingItem","focusTopTrailingItem","focusBottomLeadingItem","focusBottomTrailingItem","onResize","columns","numColumns","rows","numRows","container","gridComputedStyle","getPropertyValue","containerWidth","offsetWidth","targetsArray","acc","n","m","cell","Math","floor","nextCell","gap","offsetLeft","ceil","rowIndex","maxIndex","wrap","nextIndex","next","inert","disabled","minIndex","previousIndex","prev","downIndex","down","upIndex","up","targetColumnIndex","homeTarget","home","endTarget","end","targetRowIndex","topTarget","top","bottomTarget","bottom","topLeading","topTrailing","bottomLeading","bottomTrailing","item","active","tabIndex","focus","_ref5","startingPoint","_step4","element","_ref5$target","targetSelector","_ref5$wrap","_ref5$VKMap","querySelectorAll","_iterator4","addEventListener","mo","MutationObserver","mutationList","observer","mutation","type","updatedTargets","currentColumns","currentIndex","currentRowIndex","currentColumnIndex","min","targetPoint","_step2","_iterator2","onDOMChange","observe","childList","subtree","createMutationObserver","ro","ResizeObserver","_iterator3","createResizeObserver","_temp","_ref4","_ref4$observers","observers","parent","parentNode","x","removedNodes","nodeType","removedEl","val","removeEventListener","a","size","clear","disconnect","o","createRoverObserver","options","currentState","Error","updatedState"],"mappings":"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"}