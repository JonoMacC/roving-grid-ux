{"version":3,"file":"index.module.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @typedef {string} KeyCombo - A `+` delimited key combination (e.g. `Ctrl+Home`)\n */\n\n/**\n * @typedef {Object} VKMap - A map between virtual keys and key combinations\n * @property {KeyCombo[]} [TOP_LEFT] - The top left key combination\n * @property {KeyCombo[]} [TOP] - The top key combination\n * @property {KeyCombo[]} [TOP_RIGHT] - The top right key combination\n * @property {KeyCombo[]} [UP] - The up key combination\n * @property {KeyCombo[]} [DOWN] - The down key combination\n * @property {KeyCombo[]} [HOME] - The home key combination\n * @property {KeyCombo[]} [END] - The end key combination\n * @property {KeyCombo[]} [LEFT] - The left key combination\n * @property {KeyCombo[]} [RIGHT] - The right key combination\n * @property {KeyCombo[]} [BOTTOM_LEFT] - The bottom left key combination\n * @property {KeyCombo[]} [BOTTOM] - The bottom key combination\n * @property {KeyCombo[]} [BOTTOM_RIGHT] - The bottom right key combination\n *\n */\n\n/**\n * @typedef {Object} KeyLookup - A map between key combinations and virtual keys\n */\n\n/**\n * @typedef {Object} RoverOptions - Options for roving grid\n * @param {boolean} [options.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [options.VKMap={}] - The virtual key map for key combos\n */\n\n/**\n * @typedef {MutationObserver|ResizeObserver} AnyObserver\n */\n\nconst state = new Map();\nconst isRtl =\n  window.getComputedStyle(document.documentElement).direction === \"rtl\";\n\n/**\n * @type {VKMap}\n */\nconst DEFAULT_VK_MAP = {\n  TOP_LEFT: [],\n  TOP: [\"Ctrl+Home\", \"Meta+ArrowUp\"],\n  TOP_RIGHT: [],\n  UP: [\"ArrowUp\"],\n  DOWN: [\"ArrowDown\"],\n  HOME: [\"Home\", \"Meta+ArrowLeft\"],\n  END: [\"End\", \"Meta+ArrowRight\"],\n  LEFT: [\"ArrowLeft\"],\n  RIGHT: [\"ArrowRight\"],\n  BOTTOM_LEFT: [],\n  BOTTOM: [\"Ctrl+End\", \"Meta+ArrowDown\"],\n  BOTTOM_RIGHT: [],\n};\n\n/**\n * Returns a string for the pressed key combination, combining all modifiers\n * with '+' in order: Ctrl (^), Alt (⌥), Shift (⇧), Meta (⌘)\n *\n * @param {KeyboardEvent} e The keyboard event\n * @returns {KeyCombo} The key combination\n */\nconst keyCombo = (e) => {\n  const modifiers = [\n    e.ctrlKey ? \"Ctrl\" : null,\n    e.altKey ? \"Alt\" : null,\n    e.shiftKey ? \"Shift\" : null,\n    e.metaKey ? \"Meta\" : null,\n  ].filter(Boolean);\n  const key = e.key.length === 1 ? e.key.toUpperCase() : e.key;\n\n  return modifiers.length > 0 ? modifiers.join(\"+\") + `+${key}` : key;\n};\n\n/**\n * Swaps a key combo with a key combo in a list of key combos.\n * Used to translate from Ltr to Rtl for HOME and END virtual keys\n *\n * @param {KeyCombo[]} keys - The key combos to swap with\n * @param {KeyCombo} key - The key to swap\n * @returns {KeyCombo} The swapped key\n */\nconst swapKeys = (keys, key) => {\n  if ((key.includes(\"ArrowLeft\") || key.length == 1) && !key.includes(\"Home\")) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowRight\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  } else if (\n    (key.includes(\"ArrowRight\") || key.length == 1) &&\n    !key.includes(\"End\")\n  ) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowLeft\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  }\n  return key;\n};\n\n/**\n * Returns a virtual key lookup for each key combination, handles Rtl\n *\n * @param {VKMap} [VKMap] - The virtual key map\n * @returns {KeyLookup} The virtual key lookup map for each key combination\n */\nconst keyLookup = (VKMap = {}) => {\n  const keyMap = { ...DEFAULT_VK_MAP, ...VKMap };\n\n  if (isRtl) {\n    // Swap functionality of LEFT and RIGHT for Rtl\n    [keyMap.LEFT, keyMap.RIGHT] = [keyMap.RIGHT, keyMap.LEFT];\n    [keyMap.TOP_LEFT, keyMap.TOP_RIGHT] = [keyMap.TOP_RIGHT, keyMap.TOP_LEFT];\n    [keyMap.BOTTOM_LEFT, keyMap.BOTTOM_RIGHT] = [\n      keyMap.BOTTOM_RIGHT,\n      keyMap.BOTTOM_LEFT,\n    ];\n\n    // Swap HOME and END\n    const homeKeys = keyMap.HOME;\n    const endKeys = keyMap.END;\n    keyMap.HOME = homeKeys.map((key) => swapKeys(endKeys, key));\n    keyMap.END = endKeys.map((key) => swapKeys(homeKeys, key));\n  }\n\n  // Convert single characters to uppercase\n  for (const action in keyMap) {\n    keyMap[action] = keyMap[action].map((keyCombo) => {\n      const keys = keyCombo.split(\"+\");\n      const updatedKeys = keys.map((key) => {\n        return key.length === 1 ? key.toUpperCase() : key;\n      });\n      return updatedKeys.join(\"+\");\n    });\n  }\n\n  // Convert the keymap into a lookup for faster access\n  const keyLookup = {};\n  for (const action in keyMap) {\n    keyMap[action].forEach((keyCombo) => {\n      keyLookup[keyCombo] = action;\n    });\n  }\n  return keyLookup;\n};\n\n// When pointerdown, activate the target\nconst onPointerDown = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  const targetsArray = [...rx.targets];\n  for (const [i, t] of targetsArray.entries()) {\n    if (t.contains(e.target)) {\n      e.preventDefault();\n      rx.index = i;\n      rx.focused = true;\n      activate(rover, t);\n      state.set(\"last_rover\", rover);\n      break;\n    }\n  }\n};\n\n// When focusin, activate the target if not active\nconst onFocusin = (e) => {\n  const { currentTarget: rover, target } = e;\n  if (state.has(rover)) {\n    const rx = state.get(rover);\n    const targetIndex = [...rx.targets].indexOf(target);\n    if (targetIndex !== -1 && rx.index !== targetIndex) {\n      rx.index = targetIndex;\n      rx.focused = true;\n      activate(rover, target);\n      state.set(\"last_rover\", rover);\n    }\n  }\n};\n\nconst onFocusout = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  if (rx) rx.focused = false;\n};\n\nconst onKeydown = (e) => {\n  const { currentTarget: rover } = e;\n  const key = keyCombo(e);\n  const { keyBinds } = state.get(rover);\n  switch (keyBinds[key]) {\n    case \"RIGHT\":\n      e.preventDefault();\n      focusNextItem(rover);\n      break;\n    case \"LEFT\":\n      e.preventDefault();\n      focusPreviousItem(rover);\n      break;\n    case \"DOWN\":\n      e.preventDefault();\n      focusDownItem(rover);\n      break;\n    case \"UP\":\n      e.preventDefault();\n      focusUpItem(rover);\n      break;\n    case \"HOME\":\n      e.preventDefault();\n      focusHomeItem(rover);\n      break;\n    case \"END\":\n      e.preventDefault();\n      focusEndItem(rover);\n      break;\n    case \"BOTTOM\":\n      e.preventDefault();\n      focusBottomItem(rover);\n      break;\n    case \"TOP\":\n      e.preventDefault();\n      focusTopItem(rover);\n      break;\n    case \"TOP_LEFT\":\n      e.preventDefault();\n      focusTopLeadingItem(rover);\n      break;\n    case \"TOP_RIGHT\":\n      e.preventDefault();\n      focusTopTrailingItem(rover);\n      break;\n    case \"BOTTOM_LEFT\":\n      e.preventDefault();\n      focusBottomLeadingItem(rover);\n      break;\n    case \"BOTTOM_RIGHT\":\n      e.preventDefault();\n      focusBottomTrailingItem(rover);\n      break;\n  }\n};\n\n/**\n * When the elements in the roving grid changes, updates the rows and columns\n * and the focused element while keeping the same row and column index where\n * possible\n *\n * @param {HTMLElement} rover - The roving grid element\n * @param {string} targetSelector - The CSS target selector\n */\nconst onDOMChange = (rover, targetSelector) => {\n  const updatedTargets = rover.querySelectorAll(targetSelector);\n\n  const columns = numColumns(rover, updatedTargets);\n  const rows = numRows(rover, updatedTargets);\n\n  const rx = state.get(rover);\n  const currentColumns = rx.columns;\n  const currentIndex = rx.index;\n  const currentRowIndex = Math.floor(currentIndex / currentColumns);\n  const currentColumnIndex = currentIndex % currentColumns;\n\n  const targetIndex =\n    Math.min(currentRowIndex, rows - 1) * columns +\n    Math.min(currentColumnIndex, columns - 1);\n  const targetPoint = updatedTargets[targetIndex];\n\n  let startingPoint, index;\n  if (!(targetPoint.disabled || targetPoint.inert)) {\n    startingPoint = targetPoint;\n    index = targetIndex;\n  } else {\n    for (const target of updatedTargets) {\n      if (!target.disabled && !target.inert) {\n        startingPoint = target;\n        break;\n      }\n    }\n    index = [...updatedTargets].indexOf(startingPoint);\n  }\n\n  updatedTargets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n  rx.focused && activate(rover, startingPoint);\n\n  state.set(rover, {\n    ...rx,\n    targets: updatedTargets,\n    columns,\n    rows,\n    active: startingPoint,\n    index,\n  });\n};\n\n/**\n * When the roving grid is resized, updates the number of columns and rows\n * @param {HTMLElement} rover - The roving grid element\n */\nconst onResize = (rover) => {\n  const rx = state.get(rover);\n  const columns = numColumns(rover, [...rx.targets]);\n  const rows = numRows(rover, [...rx.targets]);\n\n  state.set(rover, {\n    ...rx,\n    columns,\n    rows,\n  });\n};\n\n/**\n * Observes the roving grid's parent node for mutations (nodes added/removed)\n * When the roving grid is removed, it detaches event listeners and disconnects\n * any observers passed in as arguments\n *\n * @param {HTMLElement} rover - The roving grid element\n * @param {AnyObserver[]} observers - A list of observers for the roving grid\n * @returns {MutationObserver} The mutation observer\n */\nconst createRoverObserver = (rover, observers = []) => {\n  const parent = rover.parentNode;\n  const mo = new MutationObserver((mutationList) => {\n    mutationList\n      .filter((x) => x.removedNodes.length > 0)\n      .forEach((mutation) => {\n        [...mutation.removedNodes]\n          .filter((x) => x.nodeType === 1)\n          .forEach((removedEl) => {\n            state.forEach((val, key) => {\n              if (key === \"last_rover\") return;\n              if (removedEl.contains(key)) {\n                key.removeEventListener(\"pointerdown\", onPointerDown);\n                key.removeEventListener(\"focusin\", onFocusin);\n                key.removeEventListener(\"focusout\", onFocusout);\n                key.removeEventListener(\"keydown\", onKeydown);\n\n                state.delete(key);\n                val.targets.forEach((a) => (a.tabIndex = \"\"));\n\n                if (\n                  state.size === 0 ||\n                  (state.size === 1 && state.has(\"last_rover\"))\n                ) {\n                  state.clear();\n                  mo.disconnect();\n                  observers.forEach((o) => o.disconnect());\n                }\n              }\n            });\n          });\n      });\n  });\n\n  mo.observe(parent, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\n/**\n * Observes the roving grid and its children for mutations (nodes added/removed)\n * and calls onDOMChange callback\n *\n * @param {HTMLElement} rover - The roving grid element\n * @param {string} targetSelector - The CSS target selector\n * @returns {MutationObserver} The mutation observer\n */\nconst createMutationObserver = (rover, targetSelector) => {\n  const mo = new MutationObserver((mutationList) => {\n    mutationList.forEach((mutation) => {\n      if (mutation.type === \"childList\" && rover.contains(mutation.target)) {\n        onDOMChange(rover, targetSelector);\n      }\n    });\n  });\n\n  mo.observe(rover, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\n/**\n * Observes the roving grid and its targets for size changes and calls\n * onResize callback\n *\n * @param {HTMLElement} rover - The roving grid element\n * @param {string} targetSelector - The CSS target selector\n * @returns {ResizeObserver} The resize observer\n */\nconst createResizeObserver = (rover, targetSelector) => {\n  const ro = new ResizeObserver(() => onResize(rover));\n\n  [rover, ...rover.querySelectorAll(targetSelector)].forEach((el) => {\n    ro.observe(el);\n  });\n\n  return ro;\n};\n\n/**\n * Calculates the number of columns in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of columns\n */\nconst numColumns = (container, targets) => {\n  // If the container uses CSS grid, get the number of columns from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-columns\");\n  if (cssGrid) {\n    return gridComputedStyle\n      .getPropertyValue(\"grid-template-columns\")\n      .split(\" \").length;\n  }\n\n  // Otherwise, calculate the number of columns with brute force using the\n  // offset widths and gaps between cells\n  const containerWidth = container.offsetWidth;\n  const targetsArray = [...targets];\n  let acc = 0;\n  let n = 0;\n  for (let i = 0, m = targetsArray.length; i < m; i++) {\n    const cell = targetsArray[i];\n\n    acc += Math.floor(cell.offsetWidth);\n\n    const nextCell = targets[i + 1];\n\n    if (nextCell) {\n      const gap = nextCell.offsetLeft - (cell.offsetLeft + cell.offsetWidth);\n      if (gap > 0) acc += Math.floor(gap);\n    }\n\n    if (acc > containerWidth) {\n      break;\n    }\n    n++;\n  }\n  return n;\n};\n\n/**\n * Calculates the number of rows in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of rows\n */\nconst numRows = (container, targets) => {\n  // If the container uses CSS grid, get the number of rows from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-rows\");\n  if (cssGrid) {\n    return gridComputedStyle.getPropertyValue(\"grid-template-rows\").split(\" \")\n      .length;\n  }\n\n  // Otherwise, calculate the number of rows as the number of targets divided\n  // by the number of columns\n  return Math.ceil(targets.length / numColumns(container, targets));\n};\n\n/**\n * @param {Object} props - The props object\n * @param {HTMLElement} props.element - The target container element\n * @param {string} [props.target] - The CSS selector for focus targets\n * @param {boolean} [props.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [props.VKMap={}] - The virtual key map for key combos\n */\nexport const rovingGrid = ({\n  element: rover,\n  target: targetSelector = \":scope *\",\n  wrap = true,\n  VKMap = {},\n}) => {\n  const targets = rover.querySelectorAll(targetSelector);\n  let startingPoint;\n  for (const target of targets) {\n    if (!target.disabled && !target.inert) {\n      startingPoint = target;\n      break;\n    }\n  }\n  const index = [...targets].indexOf(startingPoint);\n  const columns = numColumns(rover, targets);\n  const rows = numRows(rover, targets);\n  const keyBinds = keyLookup(VKMap);\n\n  rover.tabIndex = -1;\n  targets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    wrap,\n    active: startingPoint,\n    index,\n    rows,\n    columns,\n    focused: false,\n    keyBinds,\n  });\n\n  rover.addEventListener(\"pointerdown\", onPointerDown);\n  rover.addEventListener(\"focusin\", onFocusin);\n  rover.addEventListener(\"focusout\", onFocusout);\n  rover.addEventListener(\"keydown\", onKeydown);\n\n  const mo = createMutationObserver(rover, targetSelector);\n  const ro = createResizeObserver(rover, targetSelector);\n  createRoverObserver(rover, { observers: [mo, ro] });\n};\n\n/**\n * Updates the rover for on-the-fly customization of `wrap` and `VKMap`\n * @param {HTMLElement} rover - The element with roving focus\n * @param {RoverOptions} options - The roving grid options\n */\nexport const updateRover = (rover, options) => {\n  const currentState = state.get(rover);\n\n  if (!currentState) {\n    throw new Error(\"Rover not found\");\n  }\n\n  const updatedState = {\n    ...currentState,\n    ...options,\n  };\n\n  if (options.VKMap) {\n    updatedState.keyBinds = keyLookup(options.VKMap);\n  }\n\n  state.set(rover, updatedState);\n};\n\nconst focusNextItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const maxIndex = rx.wrap\n    ? rx.targets.length - 1\n    : (rowIndex + 1) * rx.columns - 1;\n  let nextIndex = rx.index;\n\n  while (nextIndex < maxIndex) {\n    nextIndex++;\n    const next = rx.targets[nextIndex];\n    if (next && !(next.inert || next.disabled)) {\n      rx.index = nextIndex;\n      activate(rover, next);\n      break;\n    }\n  }\n};\n\nconst focusPreviousItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const minIndex = rx.wrap ? 0 : rowIndex * rx.columns;\n  let previousIndex = rx.index;\n\n  while (previousIndex > minIndex) {\n    previousIndex--;\n    const prev = rx.targets[previousIndex];\n    if (prev && !(prev.inert || prev.disabled)) {\n      rx.index = previousIndex;\n      activate(rover, prev);\n      break;\n    }\n  }\n};\n\nconst focusDownItem = (rover) => {\n  const rx = state.get(rover);\n  const maxIndex = rx.rows * rx.columns + (rx.index % rx.columns);\n  let downIndex = rx.index;\n\n  while (downIndex < maxIndex) {\n    downIndex += rx.columns;\n    const down = rx.targets[downIndex];\n    if (down && !(down.inert || down.disabled)) {\n      rx.index = downIndex;\n      activate(rover, down);\n      break;\n    }\n  }\n};\n\nconst focusUpItem = (rover) => {\n  const rx = state.get(rover);\n  const minIndex = rx.index % rx.columns;\n  let upIndex = rx.index;\n\n  while (upIndex > minIndex) {\n    upIndex -= rx.columns;\n    const up = rx.targets[upIndex];\n    if (up && !(up.inert || up.disabled)) {\n      rx.index = upIndex;\n      activate(rover, up);\n      break;\n    }\n  }\n};\n\nconst focusHomeItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = 0;\n\n  // Find smallest column index that has a target\n  while (targetColumnIndex < rx.columns) {\n    const homeTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (homeTarget && !(homeTarget.inert || homeTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex++;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const home = rx.targets[rx.index];\n\n  home && activate(rover, home);\n};\n\nconst focusEndItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = rx.columns - 1;\n\n  // Find largest column index that has a target\n  while (targetColumnIndex >= 0) {\n    const endTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (endTarget && !(endTarget.inert || endTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex--;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const end = rx.targets[rx.index];\n\n  end && activate(rover, end);\n};\n\nconst focusTopItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = 0;\n\n  // Find smallest row index that has a target\n  while (targetRowIndex < rowIndex) {\n    const topTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (topTarget && !(topTarget.inert || topTarget.disabled)) {\n      break;\n    }\n    targetRowIndex++;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const top = rx.targets[rx.index];\n\n  top && activate(rover, top);\n};\n\nconst focusBottomItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = rx.rows - 1;\n\n  // Find largest row index that has a target\n  while (targetRowIndex > rowIndex) {\n    const bottomTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (bottomTarget && !(bottomTarget.inert || bottomTarget.disabled)) {\n      break;\n    }\n    targetRowIndex--;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const bottom = rx.targets[rx.index];\n\n  bottom && activate(rover, bottom);\n};\n\nconst focusTopLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const topLeading = rx.targets[0];\n\n  if (topLeading && !(topLeading.inert || topLeading.disabled)) {\n    rx.index = 0;\n    activate(rover, topLeading);\n  }\n};\n\nconst focusTopTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const topTrailing = rx.targets[rx.columns - 1];\n\n  if (topTrailing && !(topTrailing.inert || topTrailing.disabled)) {\n    rx.index = rx.columns - 1;\n    activate(rover, topTrailing);\n  }\n};\n\nconst focusBottomLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomLeading = rx.targets[rx.columns * (rx.rows - 1)];\n\n  if (bottomLeading && !(bottomLeading.inert || bottomLeading.disabled)) {\n    rx.index = rx.columns * (rx.rows - 1);\n    activate(rover, bottomLeading);\n  }\n};\n\nconst focusBottomTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomTrailing = rx.targets[rx.columns * rx.rows - 1];\n\n  if (bottomTrailing && !(bottomTrailing.inert || bottomTrailing.disabled)) {\n    rx.index = rx.columns * rx.rows - 1;\n    activate(rover, bottomTrailing);\n  }\n};\n\nconst activate = (rover, item) => {\n  const rx = state.get(rover);\n\n  rx.active.tabIndex = -1;\n  rx.active = item;\n  rx.active.tabIndex = 0;\n  rx.active.focus();\n  rx.focused = true;\n};\n"],"names":["state","Map","isRtl","window","getComputedStyle","document","documentElement","direction","DEFAULT_VK_MAP","TOP_LEFT","TOP","TOP_RIGHT","UP","DOWN","HOME","END","LEFT","RIGHT","BOTTOM_LEFT","BOTTOM","BOTTOM_RIGHT","swapKeys","keys","key","includes","length","i","findIndex","k","keyLookup","VKMap","keyMap","_extends","_ref","_ref2","_ref3","homeKeys","endKeys","map","action","keyCombo","split","toUpperCase","join","_loop","_action","forEach","onPointerDown","e","_step","rover","currentTarget","rx","get","_iterator","_createForOfIteratorHelperLoose","concat","targets","entries","done","_step$value","value","t","contains","target","preventDefault","index","focused","activate","set","onFocusin","has","targetIndex","indexOf","onFocusout","onKeydown","modifiers","ctrlKey","altKey","shiftKey","metaKey","filter","Boolean","keyBinds","focusNextItem","focusPreviousItem","focusDownItem","focusUpItem","focusHomeItem","focusEndItem","focusBottomItem","focusTopItem","focusTopLeadingItem","focusTopTrailingItem","focusBottomLeadingItem","focusBottomTrailingItem","createMutationObserver","targetSelector","mo","MutationObserver","mutationList","mutation","type","startingPoint","updatedTargets","querySelectorAll","columns","numColumns","rows","numRows","currentColumns","currentIndex","currentRowIndex","Math","floor","currentColumnIndex","min","targetPoint","disabled","inert","_iterator2","_step2","tabIndex","active","onDOMChange","observe","childList","subtree","createResizeObserver","ro","ResizeObserver","onResize","el","container","gridComputedStyle","getPropertyValue","containerWidth","offsetWidth","targetsArray","acc","n","m","cell","nextCell","gap","offsetLeft","ceil","rovingGrid","_ref4","_step3","element","_ref4$target","_ref4$wrap","wrap","_ref4$VKMap","_iterator3","addEventListener","observers","parent","parentNode","x","removedNodes","nodeType","removedEl","val","removeEventListener","a","size","clear","disconnect","o","createRoverObserver","updateRover","options","currentState","Error","updatedState","rowIndex","maxIndex","nextIndex","next","minIndex","previousIndex","prev","downIndex","down","upIndex","up","targetColumnIndex","homeTarget","home","endTarget","end","targetRowIndex","topTarget","top","bottomTarget","bottom","topLeading","topTrailing","bottomLeading","bottomTrailing","item","focus"],"mappings":"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"}