{"version":3,"file":"index.module.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @typedef {string} KeyCombo - A `+` delimited key combination (e.g. `Ctrl+Home`)\n */\n\n/**\n * @typedef {Object} VKMap - A map between virtual keys and key combinations\n * @property {KeyCombo[]} [TOP_LEFT] - The top left key combination\n * @property {KeyCombo[]} [TOP] - The top key combination\n * @property {KeyCombo[]} [TOP_RIGHT] - The top right key combination\n * @property {KeyCombo[]} [UP] - The up key combination\n * @property {KeyCombo[]} [DOWN] - The down key combination\n * @property {KeyCombo[]} [HOME] - The home key combination\n * @property {KeyCombo[]} [END] - The end key combination\n * @property {KeyCombo[]} [LEFT] - The left key combination\n * @property {KeyCombo[]} [RIGHT] - The right key combination\n * @property {KeyCombo[]} [BOTTOM_LEFT] - The bottom left key combination\n * @property {KeyCombo[]} [BOTTOM] - The bottom key combination\n * @property {KeyCombo[]} [BOTTOM_RIGHT] - The bottom right key combination\n *\n */\n\n/**\n * @typedef {Object} KeyLookup - A map between key combinations and virtual keys\n */\n\nconst state = new Map();\nconst isRtl =\n  window.getComputedStyle(document.documentElement).direction === \"rtl\";\n\n/**\n * @type {VKMap}\n */\nconst DEFAULT_VK_MAP = {\n  TOP_LEFT: [],\n  TOP: [\"Ctrl+Home\", \"Meta+ArrowUp\"],\n  TOP_RIGHT: [],\n  UP: [\"ArrowUp\"],\n  DOWN: [\"ArrowDown\"],\n  HOME: [\"Home\", \"Meta+ArrowLeft\"],\n  END: [\"End\", \"Meta+ArrowRight\"],\n  LEFT: [\"ArrowLeft\"],\n  RIGHT: [\"ArrowRight\"],\n  BOTTOM_LEFT: [],\n  BOTTOM: [\"Ctrl+End\", \"Meta+ArrowDown\"],\n  BOTTOM_RIGHT: [],\n};\n\n/**\n * Returns a string for the pressed key combination, combining all modifiers\n * with '+' in order: Ctrl (^), Alt (⌥), Shift (⇧), Meta (⌘)\n *\n * @param {KeyboardEvent} e The keyboard event\n * @returns {KeyCombo} The key combination\n */\nconst keyCombo = (e) => {\n  const modifiers = [\n    e.ctrlKey ? \"Ctrl\" : null,\n    e.altKey ? \"Alt\" : null,\n    e.shiftKey ? \"Shift\" : null,\n    e.metaKey ? \"Meta\" : null,\n  ].filter(Boolean);\n  const key = e.key.length === 1 ? e.key.toUpperCase() : e.key;\n\n  return modifiers.length > 0 ? modifiers.join(\"+\") + `+${key}` : key;\n};\n\n/**\n * Swaps a key combo with a key combo in a list of key combos.\n * Used to translate from Ltr to Rtl for HOME and END virtual keys\n * @param {KeyCombo[]} keys - The key combos to swap with\n * @param {KeyCombo} key - The key to swap\n * @returns {KeyCombo} The swapped key\n */\nconst swapKeys = (keys, key) => {\n  if ((key.includes(\"ArrowLeft\") || key.length == 1) && !key.includes(\"Home\")) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowRight\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  } else if (\n    (key.includes(\"ArrowRight\") || key.length == 1) &&\n    !key.includes(\"End\")\n  ) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowLeft\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  }\n  return key;\n};\n\n/**\n * Returns a virtual key lookup for each key combination, handles Rtl\n * @param {VKMap} [VKMap] - The virtual key map\n * @returns {KeyLookup} The virtual key lookup map for each key combination\n */\nconst keyLookup = (VKMap = {}) => {\n  const keyMap = { ...DEFAULT_VK_MAP, ...VKMap };\n\n  if (isRtl) {\n    // Swap functionality of LEFT and RIGHT for Rtl\n    [keyMap.LEFT, keyMap.RIGHT] = [keyMap.RIGHT, keyMap.LEFT];\n    [keyMap.TOP_LEFT, keyMap.TOP_RIGHT] = [keyMap.TOP_RIGHT, keyMap.TOP_LEFT];\n    [keyMap.BOTTOM_LEFT, keyMap.BOTTOM_RIGHT] = [\n      keyMap.BOTTOM_RIGHT,\n      keyMap.BOTTOM_LEFT,\n    ];\n\n    // Swap HOME and END\n    const homeKeys = keyMap.HOME;\n    const endKeys = keyMap.END;\n    keyMap.HOME = homeKeys.map((key) => swapKeys(endKeys, key));\n    keyMap.END = endKeys.map((key) => swapKeys(homeKeys, key));\n  }\n\n  // Convert single characters to uppercase\n  for (const action in keyMap) {\n    keyMap[action] = keyMap[action].map((keyCombo) => {\n      const keys = keyCombo.split(\"+\");\n      const updatedKeys = keys.map((key) => {\n        return key.length === 1 ? key.toUpperCase() : key;\n      });\n      return updatedKeys.join(\"+\");\n    });\n  }\n\n  // Convert the keymap into a lookup for faster access\n  const keyLookup = {};\n  for (const action in keyMap) {\n    keyMap[action].forEach((keyCombo) => {\n      keyLookup[keyCombo] = action;\n    });\n  }\n  return keyLookup;\n};\n\n// When pointerdown, activate the target\nconst onPointerDown = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  const targetsArray = [...rx.targets];\n  for (const [i, t] of targetsArray.entries()) {\n    if (t.contains(e.target)) {\n      e.preventDefault();\n      rx.index = i;\n      rx.focused = true;\n      activate(rover, t);\n      state.set(\"last_rover\", rover);\n      break;\n    }\n  }\n};\n\n// When focusin, activate the target if not active\nconst onFocusin = (e) => {\n  const { currentTarget: rover, target } = e;\n  if (state.has(rover)) {\n    const rx = state.get(rover);\n    const targetIndex = [...rx.targets].indexOf(target);\n    if (targetIndex !== -1 && rx.index !== targetIndex) {\n      rx.index = targetIndex;\n      rx.focused = true;\n      activate(rover, target);\n      state.set(\"last_rover\", rover);\n    }\n  }\n};\n\nconst onFocusout = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  if (rx) rx.focused = false;\n};\n\nconst onKeydown = (e) => {\n  const { currentTarget: rover } = e;\n  const key = keyCombo(e);\n  const { keyBinds } = state.get(rover);\n  switch (keyBinds[key]) {\n    case \"RIGHT\":\n      e.preventDefault();\n      focusNextItem(rover);\n      break;\n    case \"LEFT\":\n      e.preventDefault();\n      focusPreviousItem(rover);\n      break;\n    case \"DOWN\":\n      e.preventDefault();\n      focusDownItem(rover);\n      break;\n    case \"UP\":\n      e.preventDefault();\n      focusUpItem(rover);\n      break;\n    case \"HOME\":\n      e.preventDefault();\n      focusHomeItem(rover);\n      break;\n    case \"END\":\n      e.preventDefault();\n      focusEndItem(rover);\n      break;\n    case \"BOTTOM\":\n      e.preventDefault();\n      focusBottomItem(rover);\n      break;\n    case \"TOP\":\n      e.preventDefault();\n      focusTopItem(rover);\n      break;\n    case \"TOP_LEFT\":\n      e.preventDefault();\n      focusTopLeadingItem(rover);\n      break;\n    case \"TOP_RIGHT\":\n      e.preventDefault();\n      focusTopTrailingItem(rover);\n      break;\n    case \"BOTTOM_LEFT\":\n      e.preventDefault();\n      focusBottomLeadingItem(rover);\n      break;\n    case \"BOTTOM_RIGHT\":\n      e.preventDefault();\n      focusBottomTrailingItem(rover);\n      break;\n  }\n};\n\nconst updateState = (rover, targetSelector) => {\n  const updatedTargets = rover.querySelectorAll(targetSelector);\n\n  const columns = numColumns(rover, updatedTargets);\n  const rows = Math.ceil(updatedTargets.length / columns);\n\n  const rx = state.get(rover);\n  const currentColumns = rx.columns;\n  const currentIndex = rx.index;\n  const currentRowIndex = Math.floor(currentIndex / currentColumns);\n  const currentColumnIndex = currentIndex % currentColumns;\n\n  const index =\n    Math.min(currentRowIndex, rows - 1) * columns +\n    Math.min(currentColumnIndex, columns - 1);\n  const startingPoint = updatedTargets[index];\n\n  updatedTargets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n  rx.focused && activate(rover, startingPoint);\n\n  state.set(rover, {\n    ...rx,\n    targets: updatedTargets,\n    columns,\n    rows,\n    active: startingPoint,\n    index,\n  });\n};\n\nconst createRoverObserver = (rover, { observers = [] } = {}) => {\n  const parent = rover.parentNode;\n  const mo = new MutationObserver((mutationList, observer) => {\n    mutationList\n      .filter((x) => x.removedNodes.length > 0)\n      .forEach((mutation) => {\n        [...mutation.removedNodes]\n          .filter((x) => x.nodeType === 1)\n          .forEach((removedEl) => {\n            state.forEach((val, key) => {\n              if (key === \"last_rover\") return;\n              if (removedEl.contains(key)) {\n                key.removeEventListener(\"pointerdown\", onPointerDown);\n                key.removeEventListener(\"focusin\", onFocusin);\n                key.removeEventListener(\"focusout\", onFocusout);\n                key.removeEventListener(\"keydown\", onKeydown);\n\n                state.delete(key);\n                val.targets.forEach((a) => (a.tabIndex = \"\"));\n\n                if (\n                  state.size === 0 ||\n                  (state.size === 1 && state.has(\"last_rover\"))\n                ) {\n                  state.clear();\n                  mo.disconnect();\n                  observers.forEach((o) => o.disconnect());\n                }\n              }\n            });\n          });\n      });\n  });\n\n  mo.observe(parent, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\nconst createMutationObserver = (rover, targetSelector) => {\n  const mo = new MutationObserver((mutationList, observer) => {\n    mutationList.forEach((mutation) => {\n      if (mutation.type === \"childList\" && rover.contains(mutation.target)) {\n        updateState(rover, targetSelector);\n      }\n    });\n  });\n\n  mo.observe(rover, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\nconst createResizeObserver = (rover, targetSelector) => {\n  const ro = new ResizeObserver((entries) => {\n    for (const entry of entries) {\n      updateState(rover, targetSelector);\n    }\n  });\n\n  ro.observe(rover);\n  rover.querySelectorAll(targetSelector).forEach((t) => {\n    ro.observe(t);\n  });\n\n  return ro;\n};\n\n/**\n * Calculates the number of columns in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of columns\n */\nconst numColumns = (container, targets) => {\n  // If the container uses CSS grid, get the number of columns from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-columns\");\n  if (cssGrid) {\n    return gridComputedStyle\n      .getPropertyValue(\"grid-template-columns\")\n      .split(\" \").length;\n  }\n\n  // Otherwise, calculate the number of columns with brute force using the\n  // offset widths and gaps between cells\n  const containerWidth = container.offsetWidth;\n  const targetsArray = [...targets];\n  let acc = 0;\n  let n = 0;\n  for (let i = 0, m = targetsArray.length; i < m; i++) {\n    const cell = targetsArray[i];\n\n    acc += Math.floor(cell.offsetWidth);\n\n    const nextCell = targets[i + 1];\n\n    if (nextCell) {\n      const gap = nextCell.offsetLeft - (cell.offsetLeft + cell.offsetWidth);\n      if (gap > 0) acc += Math.floor(gap);\n    }\n\n    if (acc > containerWidth) {\n      break;\n    }\n    n++;\n  }\n  return n;\n};\n\n/**\n * Calculates the number of rows in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of rows\n */\nconst numRows = (container, targets) => {\n  // If the container uses CSS grid, get the number of rows from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-rows\");\n  if (cssGrid) {\n    return gridComputedStyle.getPropertyValue(\"grid-template-rows\").split(\" \")\n      .length;\n  }\n\n  // Otherwise, calculate the number of rows as the number of targets divided\n  // by the number of columns\n  return Math.ceil(targets.length / numColumns(container, targets));\n};\n\n/**\n * @param {Object} props - The props object\n * @param {HTMLElement} props.element - The target container element\n * @param {string} [props.target] - The selector for focus targets (e.g. cells)\n * @param {boolean} [props.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [props.VKMap={}] - The virtual key map for key combos\n */\nexport const rovingGrid = ({\n  element: rover,\n  target: targetSelector = \":scope *\",\n  wrap = true,\n  VKMap = {},\n}) => {\n  const targets = rover.querySelectorAll(targetSelector);\n  const startingPoint = targets[0];\n  const columns = numColumns(rover, targets);\n  const rows = numRows(rover, targets);\n  const keyBinds = keyLookup(VKMap);\n\n  rover.tabIndex = -1;\n  targets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    wrap,\n    active: startingPoint,\n    index: 0,\n    rows,\n    columns,\n    focused: false,\n    keyBinds,\n  });\n\n  rover.addEventListener(\"pointerdown\", onPointerDown);\n  rover.addEventListener(\"focusin\", onFocusin);\n  rover.addEventListener(\"focusout\", onFocusout);\n  rover.addEventListener(\"keydown\", onKeydown);\n\n  const mo = createMutationObserver(rover, targetSelector);\n  const ro = createResizeObserver(rover, targetSelector);\n  createRoverObserver(rover, { observers: [mo, ro] });\n};\n\n/**\n * @typedef {Object} RoverOptions - Options for roving grid\n * @param {boolean} [options.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [options.VKMap={}] - The virtual key map for key combos\n */\n\n/**\n * Updates the rover for on-the-fly customization of `wrap` and `VKMap`\n * @param {HTMLElement} rover - The element with roving focus\n * @param {RoverOptions} options - The roving grid options\n */\nexport const updateRover = (rover, options) => {\n  const currentState = state.get(rover);\n\n  if (!currentState) {\n    throw new Error(\"Rover not found\");\n  }\n\n  const updatedState = {\n    ...currentState,\n    ...options,\n  };\n\n  if (options.VKMap) {\n    updatedState.keyBinds = keyLookup(options.VKMap);\n  }\n\n  state.set(rover, updatedState);\n};\n\nconst focusNextItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const maxIndex = rx.wrap\n    ? rx.targets.length - 1\n    : (rowIndex + 1) * rx.columns - 1;\n  let nextIndex = rx.index;\n\n  while (nextIndex < maxIndex) {\n    nextIndex++;\n    const next = rx.targets[nextIndex];\n    if (next && !(next.inert || next.disabled)) {\n      rx.index = nextIndex;\n      activate(rover, next);\n      break;\n    }\n  }\n};\n\nconst focusPreviousItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const minIndex = rx.wrap ? 0 : rowIndex * rx.columns;\n  let previousIndex = rx.index;\n\n  while (previousIndex > minIndex) {\n    previousIndex--;\n    const prev = rx.targets[previousIndex];\n    if (prev && !(prev.inert || prev.disabled)) {\n      rx.index = previousIndex;\n      activate(rover, prev);\n      break;\n    }\n  }\n};\n\nconst focusDownItem = (rover) => {\n  const rx = state.get(rover);\n  const maxIndex = rx.rows * rx.columns + (rx.index % rx.columns);\n  let downIndex = rx.index;\n\n  while (downIndex < maxIndex) {\n    downIndex += rx.columns;\n    const down = rx.targets[downIndex];\n    if (down && !(down.inert || down.disabled)) {\n      rx.index = downIndex;\n      activate(rover, down);\n      break;\n    }\n  }\n};\n\nconst focusUpItem = (rover) => {\n  const rx = state.get(rover);\n  const minIndex = rx.index % rx.columns;\n  let upIndex = rx.index;\n\n  while (upIndex > minIndex) {\n    upIndex -= rx.columns;\n    const up = rx.targets[upIndex];\n    if (up && !(up.inert || up.disabled)) {\n      rx.index = upIndex;\n      activate(rover, up);\n      break;\n    }\n  }\n};\n\nconst focusHomeItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = 0;\n\n  // Find smallest column index that has a target\n  while (targetColumnIndex < rx.columns) {\n    const homeTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (homeTarget && !(homeTarget.inert || homeTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex++;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const home = rx.targets[rx.index];\n\n  home && activate(rover, home);\n};\n\nconst focusEndItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = rx.columns - 1;\n\n  // Find largest column index that has a target\n  while (targetColumnIndex >= 0) {\n    const endTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (endTarget && !(endTarget.inert || endTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex--;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const end = rx.targets[rx.index];\n\n  end && activate(rover, end);\n};\n\nconst focusTopItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = 0;\n\n  // Find smallest row index that has a target\n  while (targetRowIndex < rowIndex) {\n    const topTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (topTarget && !(topTarget.inert || topTarget.disabled)) {\n      break;\n    }\n    targetRowIndex++;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const top = rx.targets[rx.index];\n\n  top && activate(rover, top);\n};\n\nconst focusBottomItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = rx.rows - 1;\n\n  // Find largest row index that has a target\n  while (targetRowIndex > rowIndex) {\n    const bottomTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (bottomTarget && !(bottomTarget.inert || bottomTarget.disabled)) {\n      break;\n    }\n    targetRowIndex--;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const bottom = rx.targets[rx.index];\n\n  bottom && activate(rover, bottom);\n};\n\nconst focusTopLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const topLeading = rx.targets[0];\n\n  if (topLeading && !(topLeading.inert || topLeading.disabled)) {\n    rx.index = 0;\n    activate(rover, topLeading);\n  }\n};\n\nconst focusTopTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const topTrailing = rx.targets[rx.columns - 1];\n\n  if (topTrailing && !(topTrailing.inert || topTrailing.disabled)) {\n    rx.index = rx.columns - 1;\n    activate(rover, topTrailing);\n  }\n};\n\nconst focusBottomLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomLeading = rx.targets[rx.columns * (rx.rows - 1)];\n\n  if (bottomLeading && !(bottomLeading.inert || bottomLeading.disabled)) {\n    rx.index = rx.columns * (rx.rows - 1);\n    activate(rover, bottomLeading);\n  }\n};\n\nconst focusBottomTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomTrailing = rx.targets[rx.columns * rx.rows - 1];\n\n  if (bottomTrailing && !(bottomTrailing.inert || bottomTrailing.disabled)) {\n    rx.index = rx.columns * rx.rows - 1;\n    activate(rover, bottomTrailing);\n  }\n};\n\nconst activate = (rover, item) => {\n  const rx = state.get(rover);\n\n  rx.active.tabIndex = -1;\n  rx.active = item;\n  rx.active.tabIndex = 0;\n  rx.active.focus();\n  rx.focused = true;\n};\n"],"names":["state","Map","isRtl","window","getComputedStyle","document","documentElement","direction","DEFAULT_VK_MAP","TOP_LEFT","TOP","TOP_RIGHT","UP","DOWN","HOME","END","LEFT","RIGHT","BOTTOM_LEFT","BOTTOM","BOTTOM_RIGHT","swapKeys","keys","key","includes","length","i","findIndex","k","keyLookup","VKMap","keyMap","_extends","_ref","_ref2","_ref3","homeKeys","endKeys","map","action","keyCombo","split","toUpperCase","join","_loop","_action","forEach","onPointerDown","e","_step","rover","currentTarget","rx","get","_iterator","_createForOfIteratorHelperLoose","concat","targets","entries","done","_step$value","value","t","contains","target","preventDefault","index","focused","activate","set","onFocusin","has","targetIndex","indexOf","onFocusout","onKeydown","modifiers","ctrlKey","altKey","shiftKey","metaKey","filter","Boolean","keyBinds","focusNextItem","focusPreviousItem","focusDownItem","focusUpItem","focusHomeItem","focusEndItem","focusBottomItem","focusTopItem","focusTopLeadingItem","focusTopTrailingItem","focusBottomLeadingItem","focusBottomTrailingItem","updateState","targetSelector","updatedTargets","querySelectorAll","columns","numColumns","rows","Math","ceil","currentColumns","currentIndex","currentRowIndex","floor","currentColumnIndex","min","startingPoint","tabIndex","active","container","gridComputedStyle","getPropertyValue","containerWidth","offsetWidth","targetsArray","acc","n","m","cell","nextCell","gap","offsetLeft","rovingGrid","_ref5","element","_ref5$target","_ref5$wrap","wrap","_ref5$VKMap","numRows","addEventListener","mo","MutationObserver","mutationList","observer","mutation","type","observe","childList","subtree","createMutationObserver","ro","ResizeObserver","_iterator2","createResizeObserver","_temp","_ref4$observers","observers","parent","parentNode","x","removedNodes","nodeType","removedEl","val","removeEventListener","a","size","clear","disconnect","o","createRoverObserver","updateRover","options","currentState","Error","updatedState","rowIndex","maxIndex","nextIndex","next","inert","disabled","minIndex","previousIndex","prev","downIndex","down","upIndex","up","targetColumnIndex","homeTarget","home","endTarget","end","targetRowIndex","topTarget","top","bottomTarget","bottom","topLeading","topTrailing","bottomLeading","bottomTrailing","item","focus"],"mappings":"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"}