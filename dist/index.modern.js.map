{"version":3,"file":"index.modern.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @typedef {string} KeyCombo - A `+` delimited key combination (e.g. `Ctrl+Home`)\n */\n\n/**\n * @typedef {Object} VKMap - A map between virtual keys and key combinations\n * @property {KeyCombo[]} [TOP_LEFT] - The top left key combination\n * @property {KeyCombo[]} [TOP] - The top key combination\n * @property {KeyCombo[]} [TOP_RIGHT] - The top right key combination\n * @property {KeyCombo[]} [UP] - The up key combination\n * @property {KeyCombo[]} [DOWN] - The down key combination\n * @property {KeyCombo[]} [HOME] - The home key combination\n * @property {KeyCombo[]} [END] - The end key combination\n * @property {KeyCombo[]} [LEFT] - The left key combination\n * @property {KeyCombo[]} [RIGHT] - The right key combination\n * @property {KeyCombo[]} [BOTTOM_LEFT] - The bottom left key combination\n * @property {KeyCombo[]} [BOTTOM] - The bottom key combination\n * @property {KeyCombo[]} [BOTTOM_RIGHT] - The bottom right key combination\n *\n */\n\n/**\n * @typedef {Object} KeyLookup - A map between key combinations and virtual keys\n */\n\nconst state = new Map();\nconst isRtl =\n  window.getComputedStyle(document.documentElement).direction === \"rtl\";\n\n/**\n * @type {VKMap}\n */\nconst DEFAULT_VK_MAP = {\n  TOP_LEFT: [],\n  TOP: [\"Ctrl+Home\", \"Meta+ArrowUp\"],\n  TOP_RIGHT: [],\n  UP: [\"ArrowUp\"],\n  DOWN: [\"ArrowDown\"],\n  HOME: [\"Home\", \"Meta+ArrowLeft\"],\n  END: [\"End\", \"Meta+ArrowRight\"],\n  LEFT: [\"ArrowLeft\"],\n  RIGHT: [\"ArrowRight\"],\n  BOTTOM_LEFT: [],\n  BOTTOM: [\"Ctrl+End\", \"Meta+ArrowDown\"],\n  BOTTOM_RIGHT: [],\n};\n\n/**\n * Returns a string for the pressed key combination, combining all modifiers\n * with '+' in order: Ctrl (^), Alt (⌥), Shift (⇧), Meta (⌘)\n *\n * @param {KeyboardEvent} e The keyboard event\n * @returns {KeyCombo} The key combination\n */\nconst keyCombo = (e) => {\n  const modifiers = [\n    e.ctrlKey ? \"Ctrl\" : null,\n    e.altKey ? \"Alt\" : null,\n    e.shiftKey ? \"Shift\" : null,\n    e.metaKey ? \"Meta\" : null,\n  ].filter(Boolean);\n  const key = e.key.length === 1 ? e.key.toUpperCase() : e.key;\n\n  return modifiers.length > 0 ? modifiers.join(\"+\") + `+${key}` : key;\n};\n\n/**\n * Swaps a key combo with a key combo in a list of key combos.\n * Used to translate from Ltr to Rtl for HOME and END virtual keys\n * @param {KeyCombo[]} keys - The key combos to swap with\n * @param {KeyCombo} key - The key to swap\n * @returns {KeyCombo} The swapped key\n */\nconst swapKeys = (keys, key) => {\n  if ((key.includes(\"ArrowLeft\") || key.length == 1) && !key.includes(\"Home\")) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowRight\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  } else if (\n    (key.includes(\"ArrowRight\") || key.length == 1) &&\n    !key.includes(\"End\")\n  ) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowLeft\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  }\n  return key;\n};\n\n/**\n * Returns a virtual key lookup for each key combination, handles Rtl\n * @param {VKMap} [VKMap] - The virtual key map\n * @returns {KeyLookup} The virtual key lookup map for each key combination\n */\nconst keyLookup = (VKMap = {}) => {\n  const keyMap = { ...DEFAULT_VK_MAP, ...VKMap };\n\n  if (isRtl) {\n    // Swap functionality of LEFT and RIGHT for Rtl\n    [keyMap.LEFT, keyMap.RIGHT] = [keyMap.RIGHT, keyMap.LEFT];\n    [keyMap.TOP_LEFT, keyMap.TOP_RIGHT] = [keyMap.TOP_RIGHT, keyMap.TOP_LEFT];\n    [keyMap.BOTTOM_LEFT, keyMap.BOTTOM_RIGHT] = [\n      keyMap.BOTTOM_RIGHT,\n      keyMap.BOTTOM_LEFT,\n    ];\n\n    // Swap HOME and END\n    const homeKeys = keyMap.HOME;\n    const endKeys = keyMap.END;\n    keyMap.HOME = homeKeys.map((key) => swapKeys(endKeys, key));\n    keyMap.END = endKeys.map((key) => swapKeys(homeKeys, key));\n  }\n\n  // Convert single characters to uppercase\n  for (const action in keyMap) {\n    keyMap[action] = keyMap[action].map((keyCombo) => {\n      const keys = keyCombo.split(\"+\");\n      const updatedKeys = keys.map((key) => {\n        return key.length === 1 ? key.toUpperCase() : key;\n      });\n      return updatedKeys.join(\"+\");\n    });\n  }\n\n  // Convert the keymap into a lookup for faster access\n  const keyLookup = {};\n  for (const action in keyMap) {\n    keyMap[action].forEach((keyCombo) => {\n      keyLookup[keyCombo] = action;\n    });\n  }\n  return keyLookup;\n};\n\n// When pointerdown, activate the target\nconst onPointerDown = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  const targetsArray = [...rx.targets];\n  for (const [i, t] of targetsArray.entries()) {\n    if (t.contains(e.target)) {\n      e.preventDefault();\n      rx.index = i;\n      rx.focused = true;\n      activate(rover, t);\n      state.set(\"last_rover\", rover);\n      break;\n    }\n  }\n};\n\n// When focusin, activate the target if not active\nconst onFocusin = (e) => {\n  const { currentTarget: rover, target } = e;\n  if (state.has(rover)) {\n    const rx = state.get(rover);\n    const targetIndex = [...rx.targets].indexOf(target);\n    if (targetIndex !== -1 && rx.index !== targetIndex) {\n      rx.index = targetIndex;\n      rx.focused = true;\n      activate(rover, target);\n      state.set(\"last_rover\", rover);\n    }\n  }\n};\n\nconst onFocusout = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  if (rx) rx.focused = false;\n};\n\nconst onKeydown = (e) => {\n  const { currentTarget: rover } = e;\n  const key = keyCombo(e);\n  const { keyBinds } = state.get(rover);\n  switch (keyBinds[key]) {\n    case \"RIGHT\":\n      e.preventDefault();\n      focusNextItem(rover);\n      break;\n    case \"LEFT\":\n      e.preventDefault();\n      focusPreviousItem(rover);\n      break;\n    case \"DOWN\":\n      e.preventDefault();\n      focusDownItem(rover);\n      break;\n    case \"UP\":\n      e.preventDefault();\n      focusUpItem(rover);\n      break;\n    case \"HOME\":\n      e.preventDefault();\n      focusHomeItem(rover);\n      break;\n    case \"END\":\n      e.preventDefault();\n      focusEndItem(rover);\n      break;\n    case \"BOTTOM\":\n      e.preventDefault();\n      focusBottomItem(rover);\n      break;\n    case \"TOP\":\n      e.preventDefault();\n      focusTopItem(rover);\n      break;\n    case \"TOP_LEFT\":\n      e.preventDefault();\n      focusTopLeadingItem(rover);\n      break;\n    case \"TOP_RIGHT\":\n      e.preventDefault();\n      focusTopTrailingItem(rover);\n      break;\n    case \"BOTTOM_LEFT\":\n      e.preventDefault();\n      focusBottomLeadingItem(rover);\n      break;\n    case \"BOTTOM_RIGHT\":\n      e.preventDefault();\n      focusBottomTrailingItem(rover);\n      break;\n  }\n};\n\nconst onDOMChange = (rover, targetSelector) => {\n  const updatedTargets = rover.querySelectorAll(targetSelector);\n\n  const columns = numColumns(rover, updatedTargets);\n  const rows = numRows(rover, updatedTargets);\n\n  const rx = state.get(rover);\n  const currentColumns = rx.columns;\n  const currentIndex = rx.index;\n  const currentRowIndex = Math.floor(currentIndex / currentColumns);\n  const currentColumnIndex = currentIndex % currentColumns;\n\n  const targetIndex =\n    Math.min(currentRowIndex, rows - 1) * columns +\n    Math.min(currentColumnIndex, columns - 1);\n  const targetPoint = updatedTargets[targetIndex];\n\n  let startingPoint, index;\n  if (!(targetPoint.disabled || targetPoint.inert)) {\n    startingPoint = targetPoint;\n    index = targetIndex;\n  } else {\n    for (const target of updatedTargets) {\n      if (!target.disabled && !target.inert) {\n        startingPoint = target;\n        break;\n      }\n    }\n    index = [...updatedTargets].indexOf(startingPoint);\n  }\n\n  updatedTargets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n  rx.focused && activate(rover, startingPoint);\n\n  state.set(rover, {\n    ...rx,\n    targets: updatedTargets,\n    columns,\n    rows,\n    active: startingPoint,\n    index,\n  });\n};\n\nconst onResize = (rover) => {\n  const rx = state.get(rover);\n  const columns = numColumns(rover, [...rx.targets]);\n  const rows = numRows(rover, [...rx.targets]);\n\n  state.set(rover, {\n    ...rx,\n    columns,\n    rows,\n  });\n};\n\nconst createRoverObserver = (rover, { observers = [] } = {}) => {\n  const parent = rover.parentNode;\n  const mo = new MutationObserver((mutationList, observer) => {\n    mutationList\n      .filter((x) => x.removedNodes.length > 0)\n      .forEach((mutation) => {\n        [...mutation.removedNodes]\n          .filter((x) => x.nodeType === 1)\n          .forEach((removedEl) => {\n            state.forEach((val, key) => {\n              if (key === \"last_rover\") return;\n              if (removedEl.contains(key)) {\n                key.removeEventListener(\"pointerdown\", onPointerDown);\n                key.removeEventListener(\"focusin\", onFocusin);\n                key.removeEventListener(\"focusout\", onFocusout);\n                key.removeEventListener(\"keydown\", onKeydown);\n\n                state.delete(key);\n                val.targets.forEach((a) => (a.tabIndex = \"\"));\n\n                if (\n                  state.size === 0 ||\n                  (state.size === 1 && state.has(\"last_rover\"))\n                ) {\n                  state.clear();\n                  mo.disconnect();\n                  observers.forEach((o) => o.disconnect());\n                }\n              }\n            });\n          });\n      });\n  });\n\n  mo.observe(parent, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\nconst createMutationObserver = (rover, targetSelector) => {\n  const mo = new MutationObserver((mutationList, observer) => {\n    mutationList.forEach((mutation) => {\n      if (mutation.type === \"childList\" && rover.contains(mutation.target)) {\n        onDOMChange(rover, targetSelector);\n      }\n    });\n  });\n\n  mo.observe(rover, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\nconst createResizeObserver = (rover, targetSelector) => {\n  const ro = new ResizeObserver((entries) => {\n    for (const entry of entries) {\n      onResize(rover);\n    }\n  });\n\n  ro.observe(rover);\n  rover.querySelectorAll(targetSelector).forEach((t) => {\n    ro.observe(t);\n  });\n\n  return ro;\n};\n\n/**\n * Calculates the number of columns in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of columns\n */\nconst numColumns = (container, targets) => {\n  // If the container uses CSS grid, get the number of columns from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-columns\");\n  if (cssGrid) {\n    return gridComputedStyle\n      .getPropertyValue(\"grid-template-columns\")\n      .split(\" \").length;\n  }\n\n  // Otherwise, calculate the number of columns with brute force using the\n  // offset widths and gaps between cells\n  const containerWidth = container.offsetWidth;\n  const targetsArray = [...targets];\n  let acc = 0;\n  let n = 0;\n  for (let i = 0, m = targetsArray.length; i < m; i++) {\n    const cell = targetsArray[i];\n\n    acc += Math.floor(cell.offsetWidth);\n\n    const nextCell = targets[i + 1];\n\n    if (nextCell) {\n      const gap = nextCell.offsetLeft - (cell.offsetLeft + cell.offsetWidth);\n      if (gap > 0) acc += Math.floor(gap);\n    }\n\n    if (acc > containerWidth) {\n      break;\n    }\n    n++;\n  }\n  return n;\n};\n\n/**\n * Calculates the number of rows in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of rows\n */\nconst numRows = (container, targets) => {\n  // If the container uses CSS grid, get the number of rows from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-rows\");\n  if (cssGrid) {\n    return gridComputedStyle.getPropertyValue(\"grid-template-rows\").split(\" \")\n      .length;\n  }\n\n  // Otherwise, calculate the number of rows as the number of targets divided\n  // by the number of columns\n  return Math.ceil(targets.length / numColumns(container, targets));\n};\n\n/**\n * @param {Object} props - The props object\n * @param {HTMLElement} props.element - The target container element\n * @param {string} [props.target] - The selector for focus targets (e.g. cells)\n * @param {boolean} [props.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [props.VKMap={}] - The virtual key map for key combos\n */\nexport const rovingGrid = ({\n  element: rover,\n  target: targetSelector = \":scope *\",\n  wrap = true,\n  VKMap = {},\n}) => {\n  const targets = rover.querySelectorAll(targetSelector);\n  let startingPoint;\n  for (const target of targets) {\n    if (!target.disabled && !target.inert) {\n      startingPoint = target;\n      break;\n    }\n  }\n  const index = [...targets].indexOf(startingPoint);\n  const columns = numColumns(rover, targets);\n  const rows = numRows(rover, targets);\n  const keyBinds = keyLookup(VKMap);\n\n  rover.tabIndex = -1;\n  targets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    wrap,\n    active: startingPoint,\n    index,\n    rows,\n    columns,\n    focused: false,\n    keyBinds,\n  });\n\n  rover.addEventListener(\"pointerdown\", onPointerDown);\n  rover.addEventListener(\"focusin\", onFocusin);\n  rover.addEventListener(\"focusout\", onFocusout);\n  rover.addEventListener(\"keydown\", onKeydown);\n\n  const mo = createMutationObserver(rover, targetSelector);\n  const ro = createResizeObserver(rover, targetSelector);\n  createRoverObserver(rover, { observers: [mo, ro] });\n};\n\n/**\n * @typedef {Object} RoverOptions - Options for roving grid\n * @param {boolean} [options.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [options.VKMap={}] - The virtual key map for key combos\n */\n\n/**\n * Updates the rover for on-the-fly customization of `wrap` and `VKMap`\n * @param {HTMLElement} rover - The element with roving focus\n * @param {RoverOptions} options - The roving grid options\n */\nexport const updateRover = (rover, options) => {\n  const currentState = state.get(rover);\n\n  if (!currentState) {\n    throw new Error(\"Rover not found\");\n  }\n\n  const updatedState = {\n    ...currentState,\n    ...options,\n  };\n\n  if (options.VKMap) {\n    updatedState.keyBinds = keyLookup(options.VKMap);\n  }\n\n  state.set(rover, updatedState);\n};\n\nconst focusNextItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const maxIndex = rx.wrap\n    ? rx.targets.length - 1\n    : (rowIndex + 1) * rx.columns - 1;\n  let nextIndex = rx.index;\n\n  while (nextIndex < maxIndex) {\n    nextIndex++;\n    const next = rx.targets[nextIndex];\n    if (next && !(next.inert || next.disabled)) {\n      rx.index = nextIndex;\n      activate(rover, next);\n      break;\n    }\n  }\n};\n\nconst focusPreviousItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const minIndex = rx.wrap ? 0 : rowIndex * rx.columns;\n  let previousIndex = rx.index;\n\n  while (previousIndex > minIndex) {\n    previousIndex--;\n    const prev = rx.targets[previousIndex];\n    if (prev && !(prev.inert || prev.disabled)) {\n      rx.index = previousIndex;\n      activate(rover, prev);\n      break;\n    }\n  }\n};\n\nconst focusDownItem = (rover) => {\n  const rx = state.get(rover);\n  const maxIndex = rx.rows * rx.columns + (rx.index % rx.columns);\n  let downIndex = rx.index;\n\n  while (downIndex < maxIndex) {\n    downIndex += rx.columns;\n    const down = rx.targets[downIndex];\n    if (down && !(down.inert || down.disabled)) {\n      rx.index = downIndex;\n      activate(rover, down);\n      break;\n    }\n  }\n};\n\nconst focusUpItem = (rover) => {\n  const rx = state.get(rover);\n  const minIndex = rx.index % rx.columns;\n  let upIndex = rx.index;\n\n  while (upIndex > minIndex) {\n    upIndex -= rx.columns;\n    const up = rx.targets[upIndex];\n    if (up && !(up.inert || up.disabled)) {\n      rx.index = upIndex;\n      activate(rover, up);\n      break;\n    }\n  }\n};\n\nconst focusHomeItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = 0;\n\n  // Find smallest column index that has a target\n  while (targetColumnIndex < rx.columns) {\n    const homeTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (homeTarget && !(homeTarget.inert || homeTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex++;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const home = rx.targets[rx.index];\n\n  home && activate(rover, home);\n};\n\nconst focusEndItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = rx.columns - 1;\n\n  // Find largest column index that has a target\n  while (targetColumnIndex >= 0) {\n    const endTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (endTarget && !(endTarget.inert || endTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex--;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const end = rx.targets[rx.index];\n\n  end && activate(rover, end);\n};\n\nconst focusTopItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = 0;\n\n  // Find smallest row index that has a target\n  while (targetRowIndex < rowIndex) {\n    const topTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (topTarget && !(topTarget.inert || topTarget.disabled)) {\n      break;\n    }\n    targetRowIndex++;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const top = rx.targets[rx.index];\n\n  top && activate(rover, top);\n};\n\nconst focusBottomItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = rx.rows - 1;\n\n  // Find largest row index that has a target\n  while (targetRowIndex > rowIndex) {\n    const bottomTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (bottomTarget && !(bottomTarget.inert || bottomTarget.disabled)) {\n      break;\n    }\n    targetRowIndex--;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const bottom = rx.targets[rx.index];\n\n  bottom && activate(rover, bottom);\n};\n\nconst focusTopLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const topLeading = rx.targets[0];\n\n  if (topLeading && !(topLeading.inert || topLeading.disabled)) {\n    rx.index = 0;\n    activate(rover, topLeading);\n  }\n};\n\nconst focusTopTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const topTrailing = rx.targets[rx.columns - 1];\n\n  if (topTrailing && !(topTrailing.inert || topTrailing.disabled)) {\n    rx.index = rx.columns - 1;\n    activate(rover, topTrailing);\n  }\n};\n\nconst focusBottomLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomLeading = rx.targets[rx.columns * (rx.rows - 1)];\n\n  if (bottomLeading && !(bottomLeading.inert || bottomLeading.disabled)) {\n    rx.index = rx.columns * (rx.rows - 1);\n    activate(rover, bottomLeading);\n  }\n};\n\nconst focusBottomTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomTrailing = rx.targets[rx.columns * rx.rows - 1];\n\n  if (bottomTrailing && !(bottomTrailing.inert || bottomTrailing.disabled)) {\n    rx.index = rx.columns * rx.rows - 1;\n    activate(rover, bottomTrailing);\n  }\n};\n\nconst activate = (rover, item) => {\n  const rx = state.get(rover);\n\n  rx.active.tabIndex = -1;\n  rx.active = item;\n  rx.active.tabIndex = 0;\n  rx.active.focus();\n  rx.focused = true;\n};\n"],"names":["state","Map","isRtl","window","getComputedStyle","document","documentElement","direction","DEFAULT_VK_MAP","TOP_LEFT","TOP","TOP_RIGHT","UP","DOWN","HOME","END","LEFT","RIGHT","BOTTOM_LEFT","BOTTOM","BOTTOM_RIGHT","swapKeys","keys","key","includes","length","i","findIndex","k","keyLookup","VKMap","keyMap","_extends","homeKeys","endKeys","map","action","keyCombo","split","toUpperCase","join","forEach","onPointerDown","e","currentTarget","rover","rx","get","targetsArray","targets","t","entries","contains","target","preventDefault","index","focused","activate","set","onFocusin","has","targetIndex","indexOf","onFocusout","onKeydown","modifiers","ctrlKey","altKey","shiftKey","metaKey","filter","Boolean","keyBinds","focusNextItem","focusPreviousItem","focusDownItem","focusUpItem","focusHomeItem","focusEndItem","focusBottomItem","focusTopItem","focusTopLeadingItem","focusTopTrailingItem","focusBottomLeadingItem","focusBottomTrailingItem","onResize","columns","numColumns","rows","numRows","container","gridComputedStyle","getPropertyValue","containerWidth","offsetWidth","acc","n","m","cell","Math","floor","nextCell","gap","offsetLeft","ceil","rovingGrid","element","targetSelector","wrap","querySelectorAll","startingPoint","disabled","inert","tabIndex","active","addEventListener","mo","createMutationObserver","MutationObserver","mutationList","observer","mutation","type","onDOMChange","updatedTargets","currentColumns","currentIndex","currentRowIndex","currentColumnIndex","min","targetPoint","observe","childList","subtree","ro","createResizeObserver","ResizeObserver","entry","createRoverObserver","observers","parent","parentNode","x","removedNodes","nodeType","removedEl","val","removeEventListener","delete","a","size","clear","disconnect","o","updateRover","options","currentState","Error","updatedState","rowIndex","maxIndex","nextIndex","next","minIndex","previousIndex","prev","downIndex","down","upIndex","up","targetColumnIndex","homeTarget","home","endTarget","end","targetRowIndex","topTarget","top","bottomTarget","bottom","topLeading","topTrailing","bottomLeading","bottomTrailing","item","focus"],"mappings":"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"}