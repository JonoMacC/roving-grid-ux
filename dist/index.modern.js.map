{"version":3,"file":"index.modern.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @typedef {string} KeyCombo - A `+` delimited key combination (e.g. `Ctrl+Home`)\n */\n\n/**\n * @typedef {Object} VKMap - A map between virtual keys and key combinations\n * @property {KeyCombo[]} [TOP_LEFT] - The top left key combination\n * @property {KeyCombo[]} [TOP] - The top key combination\n * @property {KeyCombo[]} [TOP_RIGHT] - The top right key combination\n * @property {KeyCombo[]} [UP] - The up key combination\n * @property {KeyCombo[]} [DOWN] - The down key combination\n * @property {KeyCombo[]} [HOME] - The home key combination\n * @property {KeyCombo[]} [END] - The end key combination\n * @property {KeyCombo[]} [LEFT] - The left key combination\n * @property {KeyCombo[]} [RIGHT] - The right key combination\n * @property {KeyCombo[]} [BOTTOM_LEFT] - The bottom left key combination\n * @property {KeyCombo[]} [BOTTOM] - The bottom key combination\n * @property {KeyCombo[]} [BOTTOM_RIGHT] - The bottom right key combination\n *\n */\n\n/**\n * @typedef {Object} KeyLookup - A map between key combinations and virtual keys\n */\n\n/**\n * @typedef {Object} RoverOptions - Options for roving grid\n * @param {boolean} [options.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [options.VKMap={}] - The virtual key map for key combos\n */\n\n/**\n * @typedef {MutationObserver|ResizeObserver} AnyObserver\n */\n\nconst state = new Map();\nconst isRtl =\n  window.getComputedStyle(document.documentElement).direction === \"rtl\";\n\n/**\n * @type {VKMap}\n */\nconst DEFAULT_VK_MAP = {\n  TOP_LEFT: [],\n  TOP: [\"Ctrl+Home\", \"Meta+ArrowUp\"],\n  TOP_RIGHT: [],\n  UP: [\"ArrowUp\"],\n  DOWN: [\"ArrowDown\"],\n  HOME: [\"Home\", \"Meta+ArrowLeft\"],\n  END: [\"End\", \"Meta+ArrowRight\"],\n  LEFT: [\"ArrowLeft\"],\n  RIGHT: [\"ArrowRight\"],\n  BOTTOM_LEFT: [],\n  BOTTOM: [\"Ctrl+End\", \"Meta+ArrowDown\"],\n  BOTTOM_RIGHT: [],\n};\n\n/**\n * Returns a string for the pressed key combination, combining all modifiers\n * with '+' in order: Ctrl (^), Alt (⌥), Shift (⇧), Meta (⌘)\n *\n * @param {KeyboardEvent} e The keyboard event\n * @returns {KeyCombo} The key combination\n */\nconst keyCombo = (e) => {\n  const modifiers = [\n    e.ctrlKey ? \"Ctrl\" : null,\n    e.altKey ? \"Alt\" : null,\n    e.shiftKey ? \"Shift\" : null,\n    e.metaKey ? \"Meta\" : null,\n  ].filter(Boolean);\n  const key = e.key.length === 1 ? e.key.toUpperCase() : e.key;\n\n  return modifiers.length > 0 ? modifiers.join(\"+\") + `+${key}` : key;\n};\n\n/**\n * Swaps a key combo with a key combo in a list of key combos.\n * Used to translate from Ltr to Rtl for HOME and END virtual keys\n *\n * @param {KeyCombo[]} keys - The key combos to swap with\n * @param {KeyCombo} key - The key to swap\n * @returns {KeyCombo} The swapped key\n */\nconst swapKeys = (keys, key) => {\n  if ((key.includes(\"ArrowLeft\") || key.length == 1) && !key.includes(\"Home\")) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowRight\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  } else if (\n    (key.includes(\"ArrowRight\") || key.length == 1) &&\n    !key.includes(\"End\")\n  ) {\n    const i = keys.findIndex((k) => k.includes(\"ArrowLeft\") || k.length == 1);\n    return i !== -1 ? keys[i] : key;\n  }\n  return key;\n};\n\n/**\n * Returns a virtual key lookup for each key combination, handles Rtl\n *\n * @param {VKMap} [VKMap] - The virtual key map\n * @returns {KeyLookup} The virtual key lookup map for each key combination\n */\nconst keyLookup = (VKMap = {}) => {\n  const keyMap = { ...DEFAULT_VK_MAP, ...VKMap };\n\n  if (isRtl) {\n    // Swap functionality of LEFT and RIGHT for Rtl\n    [keyMap.LEFT, keyMap.RIGHT] = [keyMap.RIGHT, keyMap.LEFT];\n    [keyMap.TOP_LEFT, keyMap.TOP_RIGHT] = [keyMap.TOP_RIGHT, keyMap.TOP_LEFT];\n    [keyMap.BOTTOM_LEFT, keyMap.BOTTOM_RIGHT] = [\n      keyMap.BOTTOM_RIGHT,\n      keyMap.BOTTOM_LEFT,\n    ];\n\n    // Swap HOME and END\n    const homeKeys = keyMap.HOME;\n    const endKeys = keyMap.END;\n    keyMap.HOME = homeKeys.map((key) => swapKeys(endKeys, key));\n    keyMap.END = endKeys.map((key) => swapKeys(homeKeys, key));\n  }\n\n  // Convert single characters to uppercase\n  for (const action in keyMap) {\n    keyMap[action] = keyMap[action].map((keyCombo) => {\n      const keys = keyCombo.split(\"+\");\n      const updatedKeys = keys.map((key) => {\n        return key.length === 1 ? key.toUpperCase() : key;\n      });\n      return updatedKeys.join(\"+\");\n    });\n  }\n\n  // Convert the keymap into a lookup for faster access\n  const keyLookup = {};\n  for (const action in keyMap) {\n    keyMap[action].forEach((keyCombo) => {\n      keyLookup[keyCombo] = action;\n    });\n  }\n  return keyLookup;\n};\n\n// When pointerdown, activate the target\nconst onPointerDown = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  const targetsArray = [...rx.targets];\n  for (const [i, t] of targetsArray.entries()) {\n    if (t.contains(e.target)) {\n      e.preventDefault();\n      rx.index = i;\n      rx.focused = true;\n      activate(rover, t);\n      state.set(\"last_rover\", rover);\n      break;\n    }\n  }\n};\n\n// When focusin, activate the target if not active\nconst onFocusin = (e) => {\n  const { currentTarget: rover, target } = e;\n  if (state.has(rover)) {\n    const rx = state.get(rover);\n    const targetIndex = [...rx.targets].indexOf(target);\n    if (targetIndex !== -1 && rx.index !== targetIndex) {\n      rx.index = targetIndex;\n      rx.focused = true;\n      activate(rover, target);\n      state.set(\"last_rover\", rover);\n    }\n  }\n};\n\nconst onFocusout = (e) => {\n  const { currentTarget: rover } = e;\n  const rx = state.get(rover);\n  if (rx) rx.focused = false;\n};\n\nconst onKeydown = (e) => {\n  const { currentTarget: rover } = e;\n  const key = keyCombo(e);\n  const { keyBinds } = state.get(rover);\n  switch (keyBinds[key]) {\n    case \"RIGHT\":\n      e.preventDefault();\n      focusNextItem(rover);\n      break;\n    case \"LEFT\":\n      e.preventDefault();\n      focusPreviousItem(rover);\n      break;\n    case \"DOWN\":\n      e.preventDefault();\n      focusDownItem(rover);\n      break;\n    case \"UP\":\n      e.preventDefault();\n      focusUpItem(rover);\n      break;\n    case \"HOME\":\n      e.preventDefault();\n      focusHomeItem(rover);\n      break;\n    case \"END\":\n      e.preventDefault();\n      focusEndItem(rover);\n      break;\n    case \"BOTTOM\":\n      e.preventDefault();\n      focusBottomItem(rover);\n      break;\n    case \"TOP\":\n      e.preventDefault();\n      focusTopItem(rover);\n      break;\n    case \"TOP_LEFT\":\n      e.preventDefault();\n      focusTopLeadingItem(rover);\n      break;\n    case \"TOP_RIGHT\":\n      e.preventDefault();\n      focusTopTrailingItem(rover);\n      break;\n    case \"BOTTOM_LEFT\":\n      e.preventDefault();\n      focusBottomLeadingItem(rover);\n      break;\n    case \"BOTTOM_RIGHT\":\n      e.preventDefault();\n      focusBottomTrailingItem(rover);\n      break;\n  }\n};\n\n/**\n * When the elements in the roving grid changes, updates the rows and columns\n * and the focused element while keeping the same row and column index where\n * possible\n *\n * @param {HTMLElement} rover - The roving grid element\n * @param {string} targetSelector - The CSS target selector\n */\nconst onDOMChange = (rover, targetSelector) => {\n  const updatedTargets = rover.querySelectorAll(targetSelector);\n\n  const columns = numColumns(rover, updatedTargets);\n  const rows = numRows(rover, updatedTargets);\n\n  const rx = state.get(rover);\n  const currentColumns = rx.columns;\n  const currentIndex = rx.index;\n  const currentRowIndex = Math.floor(currentIndex / currentColumns);\n  const currentColumnIndex = currentIndex % currentColumns;\n\n  const targetIndex =\n    Math.min(currentRowIndex, rows - 1) * columns +\n    Math.min(currentColumnIndex, columns - 1);\n  const targetPoint = updatedTargets[targetIndex];\n\n  let startingPoint, index;\n  if (!(targetPoint.disabled || targetPoint.inert)) {\n    startingPoint = targetPoint;\n    index = targetIndex;\n  } else {\n    for (const target of updatedTargets) {\n      if (!target.disabled && !target.inert) {\n        startingPoint = target;\n        break;\n      }\n    }\n    index = [...updatedTargets].indexOf(startingPoint);\n  }\n\n  updatedTargets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n  rx.focused && activate(rover, startingPoint);\n\n  state.set(rover, {\n    ...rx,\n    targets: updatedTargets,\n    columns,\n    rows,\n    active: startingPoint,\n    index,\n  });\n};\n\n/**\n * When the roving grid is resized, updates the number of columns and rows\n * @param {HTMLElement} rover - The roving grid element\n */\nconst onResize = (rover) => {\n  const rx = state.get(rover);\n  const columns = numColumns(rover, [...rx.targets]);\n  const rows = numRows(rover, [...rx.targets]);\n\n  state.set(rover, {\n    ...rx,\n    columns,\n    rows,\n  });\n};\n\n/**\n * Observes the roving grid's parent node for mutations (nodes added/removed)\n * When the roving grid is removed, it detaches event listeners and disconnects\n * any observers passed in as arguments\n *\n * @param {HTMLElement} rover - The roving grid element\n * @param {AnyObserver[]} observers - A list of observers for the roving grid\n * @returns {MutationObserver} The mutation observer\n */\nconst createRoverObserver = (rover, observers = []) => {\n  const parent = rover.parentNode;\n  const mo = new MutationObserver((mutationList) => {\n    mutationList\n      .filter((x) => x.removedNodes.length > 0)\n      .forEach((mutation) => {\n        [...mutation.removedNodes]\n          .filter((x) => x.nodeType === 1)\n          .forEach((removedEl) => {\n            state.forEach((val, key) => {\n              if (key === \"last_rover\") return;\n              if (removedEl.contains(key)) {\n                key.removeEventListener(\"pointerdown\", onPointerDown);\n                key.removeEventListener(\"focusin\", onFocusin);\n                key.removeEventListener(\"focusout\", onFocusout);\n                key.removeEventListener(\"keydown\", onKeydown);\n\n                state.delete(key);\n                val.targets.forEach((a) => (a.tabIndex = \"\"));\n\n                if (\n                  state.size === 0 ||\n                  (state.size === 1 && state.has(\"last_rover\"))\n                ) {\n                  state.clear();\n                  mo.disconnect();\n                  observers.forEach((o) => o.disconnect());\n                }\n              }\n            });\n          });\n      });\n  });\n\n  mo.observe(parent, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\n/**\n * Observes the roving grid and its children for mutations (nodes added/removed)\n * and calls onDOMChange callback\n *\n * @param {HTMLElement} rover - The roving grid element\n * @param {string} targetSelector - The CSS target selector\n * @returns {MutationObserver} The mutation observer\n */\nconst createMutationObserver = (rover, targetSelector) => {\n  const mo = new MutationObserver((mutationList) => {\n    mutationList.forEach((mutation) => {\n      if (mutation.type === \"childList\" && rover.contains(mutation.target)) {\n        onDOMChange(rover, targetSelector);\n      }\n    });\n  });\n\n  mo.observe(rover, {\n    childList: true,\n    subtree: true,\n  });\n\n  return mo;\n};\n\n/**\n * Observes the roving grid and its targets for size changes and calls\n * onResize callback\n *\n * @param {HTMLElement} rover - The roving grid element\n * @param {string} targetSelector - The CSS target selector\n * @returns {ResizeObserver} The resize observer\n */\nconst createResizeObserver = (rover, targetSelector) => {\n  const ro = new ResizeObserver(() => onResize(rover));\n\n  [rover, ...rover.querySelectorAll(targetSelector)].forEach((el) => {\n    ro.observe(el);\n  });\n\n  return ro;\n};\n\n/**\n * Calculates the number of columns in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of columns\n */\nconst numColumns = (container, targets) => {\n  // If the container uses CSS grid, get the number of columns from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-columns\");\n  if (cssGrid) {\n    return gridComputedStyle\n      .getPropertyValue(\"grid-template-columns\")\n      .split(\" \").length;\n  }\n\n  // Otherwise, calculate the number of columns with brute force using the\n  // offset widths and gaps between cells\n  const containerWidth = container.offsetWidth;\n  const targetsArray = [...targets];\n  let acc = 0;\n  let n = 0;\n  for (let i = 0, m = targetsArray.length; i < m; i++) {\n    const cell = targetsArray[i];\n\n    acc += Math.floor(cell.offsetWidth);\n\n    const nextCell = targets[i + 1];\n\n    if (nextCell) {\n      const gap = nextCell.offsetLeft - (cell.offsetLeft + cell.offsetWidth);\n      if (gap > 0) acc += Math.floor(gap);\n    }\n\n    if (acc > containerWidth) {\n      break;\n    }\n    n++;\n  }\n  return n;\n};\n\n/**\n * Calculates the number of rows in a grid layout\n * @param {HTMLElement} container - The container element\n * @param {HTMLElement[]} targets - The target elements in the container\n * @returns {number} The number of rows\n */\nconst numRows = (container, targets) => {\n  // If the container uses CSS grid, get the number of rows from the CSS\n  const gridComputedStyle = window.getComputedStyle(container);\n  const cssGrid = gridComputedStyle.getPropertyValue(\"grid-template-rows\");\n  if (cssGrid) {\n    return gridComputedStyle.getPropertyValue(\"grid-template-rows\").split(\" \")\n      .length;\n  }\n\n  // Otherwise, calculate the number of rows as the number of targets divided\n  // by the number of columns\n  return Math.ceil(targets.length / numColumns(container, targets));\n};\n\n/**\n * @param {Object} props - The props object\n * @param {HTMLElement} props.element - The target container element\n * @param {string} [props.target] - The CSS selector for focus targets\n * @param {boolean} [props.wrap=true] - Whether focus wraps around lines\n * @param {VKMap} [props.VKMap={}] - The virtual key map for key combos\n */\nexport const rovingGrid = ({\n  element: rover,\n  target: targetSelector = \":scope *\",\n  wrap = true,\n  VKMap = {},\n}) => {\n  const targets = rover.querySelectorAll(targetSelector);\n  let startingPoint;\n  for (const target of targets) {\n    if (!target.disabled && !target.inert) {\n      startingPoint = target;\n      break;\n    }\n  }\n  const index = [...targets].indexOf(startingPoint);\n  const columns = numColumns(rover, targets);\n  const rows = numRows(rover, targets);\n  const keyBinds = keyLookup(VKMap);\n\n  rover.tabIndex = -1;\n  targets.forEach((t) => (t.tabIndex = -1));\n  startingPoint.tabIndex = 0;\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    wrap,\n    active: startingPoint,\n    index,\n    rows,\n    columns,\n    focused: false,\n    keyBinds,\n  });\n\n  rover.addEventListener(\"pointerdown\", onPointerDown);\n  rover.addEventListener(\"focusin\", onFocusin);\n  rover.addEventListener(\"focusout\", onFocusout);\n  rover.addEventListener(\"keydown\", onKeydown);\n\n  const mo = createMutationObserver(rover, targetSelector);\n  const ro = createResizeObserver(rover, targetSelector);\n  createRoverObserver(rover, { observers: [mo, ro] });\n};\n\n/**\n * Updates the rover for on-the-fly customization of `wrap` and `VKMap`\n * @param {HTMLElement} rover - The element with roving focus\n * @param {RoverOptions} options - The roving grid options\n */\nexport const updateRover = (rover, options) => {\n  const currentState = state.get(rover);\n\n  if (!currentState) {\n    throw new Error(\"Rover not found\");\n  }\n\n  const updatedState = {\n    ...currentState,\n    ...options,\n  };\n\n  if (options.VKMap) {\n    updatedState.keyBinds = keyLookup(options.VKMap);\n  }\n\n  state.set(rover, updatedState);\n};\n\nconst focusNextItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const maxIndex = rx.wrap\n    ? rx.targets.length - 1\n    : (rowIndex + 1) * rx.columns - 1;\n  let nextIndex = rx.index;\n\n  while (nextIndex < maxIndex) {\n    nextIndex++;\n    const next = rx.targets[nextIndex];\n    if (next && !(next.inert || next.disabled)) {\n      rx.index = nextIndex;\n      activate(rover, next);\n      break;\n    }\n  }\n};\n\nconst focusPreviousItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  const minIndex = rx.wrap ? 0 : rowIndex * rx.columns;\n  let previousIndex = rx.index;\n\n  while (previousIndex > minIndex) {\n    previousIndex--;\n    const prev = rx.targets[previousIndex];\n    if (prev && !(prev.inert || prev.disabled)) {\n      rx.index = previousIndex;\n      activate(rover, prev);\n      break;\n    }\n  }\n};\n\nconst focusDownItem = (rover) => {\n  const rx = state.get(rover);\n  const maxIndex = rx.rows * rx.columns + (rx.index % rx.columns);\n  let downIndex = rx.index;\n\n  while (downIndex < maxIndex) {\n    downIndex += rx.columns;\n    const down = rx.targets[downIndex];\n    if (down && !(down.inert || down.disabled)) {\n      rx.index = downIndex;\n      activate(rover, down);\n      break;\n    }\n  }\n};\n\nconst focusUpItem = (rover) => {\n  const rx = state.get(rover);\n  const minIndex = rx.index % rx.columns;\n  let upIndex = rx.index;\n\n  while (upIndex > minIndex) {\n    upIndex -= rx.columns;\n    const up = rx.targets[upIndex];\n    if (up && !(up.inert || up.disabled)) {\n      rx.index = upIndex;\n      activate(rover, up);\n      break;\n    }\n  }\n};\n\nconst focusHomeItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = 0;\n\n  // Find smallest column index that has a target\n  while (targetColumnIndex < rx.columns) {\n    const homeTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (homeTarget && !(homeTarget.inert || homeTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex++;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const home = rx.targets[rx.index];\n\n  home && activate(rover, home);\n};\n\nconst focusEndItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetColumnIndex = rx.columns - 1;\n\n  // Find largest column index that has a target\n  while (targetColumnIndex >= 0) {\n    const endTarget = rx.targets[rowIndex * rx.columns + targetColumnIndex];\n    if (endTarget && !(endTarget.inert || endTarget.disabled)) {\n      break;\n    }\n    targetColumnIndex--;\n  }\n\n  rx.index = rowIndex * rx.columns + targetColumnIndex;\n  const end = rx.targets[rx.index];\n\n  end && activate(rover, end);\n};\n\nconst focusTopItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = 0;\n\n  // Find smallest row index that has a target\n  while (targetRowIndex < rowIndex) {\n    const topTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (topTarget && !(topTarget.inert || topTarget.disabled)) {\n      break;\n    }\n    targetRowIndex++;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const top = rx.targets[rx.index];\n\n  top && activate(rover, top);\n};\n\nconst focusBottomItem = (rover) => {\n  const rx = state.get(rover);\n  const rowIndex = Math.floor(rx.index / rx.columns);\n  let targetRowIndex = rx.rows - 1;\n\n  // Find largest row index that has a target\n  while (targetRowIndex > rowIndex) {\n    const bottomTarget =\n      rx.targets[rx.index + (targetRowIndex - rowIndex) * rx.columns];\n    if (bottomTarget && !(bottomTarget.inert || bottomTarget.disabled)) {\n      break;\n    }\n    targetRowIndex--;\n  }\n\n  rx.index += rx.columns * (targetRowIndex - rowIndex);\n  const bottom = rx.targets[rx.index];\n\n  bottom && activate(rover, bottom);\n};\n\nconst focusTopLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const topLeading = rx.targets[0];\n\n  if (topLeading && !(topLeading.inert || topLeading.disabled)) {\n    rx.index = 0;\n    activate(rover, topLeading);\n  }\n};\n\nconst focusTopTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const topTrailing = rx.targets[rx.columns - 1];\n\n  if (topTrailing && !(topTrailing.inert || topTrailing.disabled)) {\n    rx.index = rx.columns - 1;\n    activate(rover, topTrailing);\n  }\n};\n\nconst focusBottomLeadingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomLeading = rx.targets[rx.columns * (rx.rows - 1)];\n\n  if (bottomLeading && !(bottomLeading.inert || bottomLeading.disabled)) {\n    rx.index = rx.columns * (rx.rows - 1);\n    activate(rover, bottomLeading);\n  }\n};\n\nconst focusBottomTrailingItem = (rover) => {\n  const rx = state.get(rover);\n  const bottomTrailing = rx.targets[rx.columns * rx.rows - 1];\n\n  if (bottomTrailing && !(bottomTrailing.inert || bottomTrailing.disabled)) {\n    rx.index = rx.columns * rx.rows - 1;\n    activate(rover, bottomTrailing);\n  }\n};\n\nconst activate = (rover, item) => {\n  const rx = state.get(rover);\n\n  rx.active.tabIndex = -1;\n  rx.active = item;\n  rx.active.tabIndex = 0;\n  rx.active.focus();\n  rx.focused = true;\n};\n"],"names":["state","Map","isRtl","window","getComputedStyle","document","documentElement","direction","DEFAULT_VK_MAP","TOP_LEFT","TOP","TOP_RIGHT","UP","DOWN","HOME","END","LEFT","RIGHT","BOTTOM_LEFT","BOTTOM","BOTTOM_RIGHT","swapKeys","keys","key","includes","length","i","findIndex","k","keyLookup","VKMap","keyMap","_extends","homeKeys","endKeys","map","action","keyCombo","split","toUpperCase","join","forEach","onPointerDown","e","currentTarget","rover","rx","get","targetsArray","targets","t","entries","contains","target","preventDefault","index","focused","activate","set","onFocusin","has","targetIndex","indexOf","onFocusout","onKeydown","modifiers","ctrlKey","altKey","shiftKey","metaKey","filter","Boolean","keyBinds","focusNextItem","focusPreviousItem","focusDownItem","focusUpItem","focusHomeItem","focusEndItem","focusBottomItem","focusTopItem","focusTopLeadingItem","focusTopTrailingItem","focusBottomLeadingItem","focusBottomTrailingItem","createMutationObserver","targetSelector","mo","MutationObserver","mutationList","mutation","type","onDOMChange","updatedTargets","querySelectorAll","columns","numColumns","rows","numRows","currentColumns","currentIndex","currentRowIndex","Math","floor","currentColumnIndex","min","targetPoint","startingPoint","disabled","inert","tabIndex","active","observe","childList","subtree","createResizeObserver","ro","ResizeObserver","onResize","el","container","gridComputedStyle","getPropertyValue","containerWidth","offsetWidth","acc","n","m","cell","nextCell","gap","offsetLeft","ceil","rovingGrid","element","wrap","addEventListener","createRoverObserver","observers","parent","parentNode","x","removedNodes","nodeType","removedEl","val","removeEventListener","delete","a","size","clear","disconnect","o","updateRover","options","currentState","Error","updatedState","rowIndex","maxIndex","nextIndex","next","minIndex","previousIndex","prev","downIndex","down","upIndex","up","targetColumnIndex","homeTarget","home","endTarget","end","targetRowIndex","topTarget","top","bottomTarget","bottom","topLeading","topTrailing","bottomLeading","bottomTrailing","item","focus"],"mappings":"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"}